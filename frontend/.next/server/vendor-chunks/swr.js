"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swr";
exports.ids = ["vendor-chunks/swr"];
exports.modules = {

/***/ "(ssr)/./node_modules/swr/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/swr/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* binding */ mutate),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar noop = function() {};\n// Using noop() as the undefined value as undefined can possibly be replaced\n// by something else.  Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nvar UNDEFINED = /*#__NOINLINE__*/ noop();\nvar OBJECT = Object;\nvar isUndefined = function(v) {\n    return v === UNDEFINED;\n};\nvar isFunction = function(v) {\n    return typeof v == \"function\";\n};\nvar mergeObjects = function(a, b) {\n    return OBJECT.assign({}, a, b);\n};\nvar STR_UNDEFINED = \"undefined\";\n// NOTE: Use function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nvar hasWindow = function() {\n    return \"undefined\" != STR_UNDEFINED;\n};\nvar hasDocument = function() {\n    return typeof document != STR_UNDEFINED;\n};\nvar hasRequestAnimationFrame = function() {\n    return hasWindow() && typeof window[\"requestAnimationFrame\"] != STR_UNDEFINED;\n};\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsible.\nvar stableHash = function(arg) {\n    var type = typeof arg;\n    var constructor = arg && arg.constructor;\n    var isDate = constructor == Date;\n    var result;\n    var index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + \"~\";\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = \"@\";\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + \",\";\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = \"#\";\n            var keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + \":\" + stableHash(arg[index]) + \",\";\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == \"symbol\" ? arg.toString() : type == \"string\" ? JSON.stringify(arg) : \"\" + arg;\n    }\n    return result;\n};\n/**\n * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a work around, we always assume it's online on first load, and change\n * the status upon `online` or `offline` events.\n */ var online = true;\nvar isOnline = function() {\n    return online;\n};\nvar hasWin = hasWindow();\nvar hasDoc = hasDocument();\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nvar onWindowEvent = hasWin && window.addEventListener ? window.addEventListener.bind(window) : noop;\nvar onDocumentEvent = hasDoc ? document.addEventListener.bind(document) : noop;\nvar offWindowEvent = hasWin && window.removeEventListener ? window.removeEventListener.bind(window) : noop;\nvar offDocumentEvent = hasDoc ? document.removeEventListener.bind(document) : noop;\nvar isVisible = function() {\n    var visibilityState = hasDoc && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== \"hidden\";\n};\nvar initFocus = function(callback) {\n    // focus revalidate\n    onDocumentEvent(\"visibilitychange\", callback);\n    onWindowEvent(\"focus\", callback);\n    return function() {\n        offDocumentEvent(\"visibilitychange\", callback);\n        offWindowEvent(\"focus\", callback);\n    };\n};\nvar initReconnect = function(callback) {\n    // revalidate on reconnected\n    var onOnline = function() {\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    var onOffline = function() {\n        online = false;\n    };\n    onWindowEvent(\"online\", onOnline);\n    onWindowEvent(\"offline\", onOffline);\n    return function() {\n        offWindowEvent(\"online\", onOnline);\n        offWindowEvent(\"offline\", onOffline);\n    };\n};\nvar preset = {\n    isOnline: isOnline,\n    isVisible: isVisible\n};\nvar defaultConfigOptions = {\n    initFocus: initFocus,\n    initReconnect: initReconnect\n};\nvar IS_SERVER = !hasWindow() || \"Deno\" in window;\n// Polyfill requestAnimationFrame\nvar rAF = function(f) {\n    return hasRequestAnimationFrame() ? window[\"requestAnimationFrame\"](f) : setTimeout(f, 1);\n};\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nvar navigatorConnection = typeof navigator !== \"undefined\" && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nvar slowConnection = !IS_SERVER && navigatorConnection && ([\n    \"slow-2g\",\n    \"2g\"\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\nvar serialize = function(key) {\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = \"\";\n        }\n    }\n    var args = [].concat(key);\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == \"string\" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : \"\";\n    var infoKey = key ? \"$swr$\" + key : \"\";\n    return [\n        key,\n        args,\n        infoKey\n    ];\n};\n// Global state used to deduplicate requests and store listeners\nvar SWRGlobalState = new WeakMap();\nvar FOCUS_EVENT = 0;\nvar RECONNECT_EVENT = 1;\nvar MUTATE_EVENT = 2;\nvar broadcastState = function(cache, key, data, error, isValidating, revalidate, broadcast) {\n    if (broadcast === void 0) {\n        broadcast = true;\n    }\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], FETCH = _a[3];\n    var revalidators = EVENT_REVALIDATORS[key];\n    var updaters = STATE_UPDATERS[key];\n    // Cache was populated, update states of all hooks.\n    if (broadcast && updaters) {\n        for(var i = 0; i < updaters.length; ++i){\n            updaters[i](data, error, isValidating);\n        }\n    }\n    // If we also need to revalidate, only do it for the first hook.\n    if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        if (revalidators && revalidators[0]) {\n            return revalidators[0](MUTATE_EVENT).then(function() {\n                return cache.get(key);\n            });\n        }\n    }\n    return cache.get(key);\n};\n// Global timestamp.\nvar __timestamp = 0;\nvar getTimestamp = function() {\n    return ++__timestamp;\n};\nvar internalMutate = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    return __awaiter(void 0, void 0, void 0, function() {\n        var cache, _key, _data, _opts, options, populateCache, revalidate, rollbackOnError, customOptimisticData, _a, key, keyInfo, _b, MUTATION, data, error, beforeMutationTs, hasCustomOptimisticData, rollbackData, optimisticData, res;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    cache = args[0], _key = args[1], _data = args[2], _opts = args[3];\n                    options = typeof _opts === \"boolean\" ? {\n                        revalidate: _opts\n                    } : _opts || {};\n                    populateCache = isUndefined(options.populateCache) ? true : options.populateCache;\n                    revalidate = options.revalidate !== false;\n                    rollbackOnError = options.rollbackOnError !== false;\n                    customOptimisticData = options.optimisticData;\n                    _a = serialize(_key), key = _a[0], keyInfo = _a[2];\n                    if (!key) return [\n                        2 /*return*/ \n                    ];\n                    _b = SWRGlobalState.get(cache), MUTATION = _b[2];\n                    // If there is no new data provided, revalidate the key with current state.\n                    if (args.length < 3) {\n                        // Revalidate and broadcast state.\n                        return [\n                            2 /*return*/ ,\n                            broadcastState(cache, key, cache.get(key), UNDEFINED, UNDEFINED, revalidate, true)\n                        ];\n                    }\n                    data = _data;\n                    beforeMutationTs = getTimestamp();\n                    MUTATION[key] = [\n                        beforeMutationTs,\n                        0\n                    ];\n                    hasCustomOptimisticData = !isUndefined(customOptimisticData);\n                    rollbackData = cache.get(key);\n                    // Do optimistic data update.\n                    if (hasCustomOptimisticData) {\n                        optimisticData = isFunction(customOptimisticData) ? customOptimisticData(rollbackData) : customOptimisticData;\n                        cache.set(key, optimisticData);\n                        broadcastState(cache, key, optimisticData);\n                    }\n                    if (isFunction(data)) {\n                        // `data` is a function, call it passing current cache value.\n                        try {\n                            data = data(cache.get(key));\n                        } catch (err) {\n                            // If it throws an error synchronously, we shouldn't update the cache.\n                            error = err;\n                        }\n                    }\n                    if (!(data && isFunction(data.then))) return [\n                        3 /*break*/ ,\n                        2\n                    ];\n                    return [\n                        4 /*yield*/ ,\n                        data.catch(function(err) {\n                            error = err;\n                        })\n                    ];\n                case 1:\n                    // This means that the mutation is async, we need to check timestamps to\n                    // avoid race conditions.\n                    data = _c.sent();\n                    // Check if other mutations have occurred since we've started this mutation.\n                    // If there's a race we don't update cache or broadcast the change,\n                    // just return the data.\n                    if (beforeMutationTs !== MUTATION[key][0]) {\n                        if (error) throw error;\n                        return [\n                            2 /*return*/ ,\n                            data\n                        ];\n                    } else if (error && hasCustomOptimisticData && rollbackOnError) {\n                        // Rollback. Always populate the cache in this case but without\n                        // transforming the data.\n                        populateCache = true;\n                        data = rollbackData;\n                        cache.set(key, rollbackData);\n                    }\n                    _c.label = 2;\n                case 2:\n                    // If we should write back the cache after request.\n                    if (populateCache) {\n                        if (!error) {\n                            // Transform the result into data.\n                            if (isFunction(populateCache)) {\n                                data = populateCache(data, rollbackData);\n                            }\n                            // Only update cached data if there's no error. Data can be `undefined` here.\n                            cache.set(key, data);\n                        }\n                        // Always update or reset the error.\n                        cache.set(keyInfo, mergeObjects(cache.get(keyInfo), {\n                            error: error\n                        }));\n                    }\n                    // Reset the timestamp to mark the mutation has ended.\n                    MUTATION[key][1] = getTimestamp();\n                    return [\n                        4 /*yield*/ ,\n                        broadcastState(cache, key, data, error, UNDEFINED, revalidate, !!populateCache)\n                    ];\n                case 3:\n                    res = _c.sent();\n                    // Throw error or return data\n                    if (error) throw error;\n                    return [\n                        2 /*return*/ ,\n                        populateCache ? res : data\n                    ];\n            }\n        });\n    });\n};\nvar revalidateAllKeys = function(revalidators, type) {\n    for(var key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nvar initCache = function(provider, options) {\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that bound to\n    // the cache.\n    // Provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        var opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        var EVENT_REVALIDATORS = {};\n        var mutate = internalMutate.bind(UNDEFINED, provider);\n        var unmount = noop;\n        // Update the state if it's new, or the provider has been extended.\n        SWRGlobalState.set(provider, [\n            EVENT_REVALIDATORS,\n            {},\n            {},\n            {},\n            mutate\n        ]);\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        if (!IS_SERVER) {\n            // When listening to the native events for auto revalidations,\n            // we intentionally put a delay (setTimeout) here to make sure they are\n            // fired after immediate JavaScript executions, which can possibly be\n            // React's state updates.\n            // This avoids some unnecessary revalidations such as\n            // https://github.com/vercel/swr/issues/1680.\n            var releaseFocus_1 = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n            var releaseReconnect_1 = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n            unmount = function() {\n                releaseFocus_1 && releaseFocus_1();\n                releaseReconnect_1 && releaseReconnect_1();\n                // When un-mounting, we need to remove the cache provider from the state\n                // storage too because it's a side-effect. Otherwise when re-mounting we\n                // will not re-register those event listeners.\n                SWRGlobalState.delete(provider);\n            };\n        }\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n// error retry\nvar onErrorRetry = function(_, __, config, revalidate, opts) {\n    var maxRetryCount = config.errorRetryCount;\n    var currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    var timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\n// Default cache provider\nvar _a = initCache(new Map()), cache = _a[0], mutate = _a[1];\n// Default config\nvar defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry: onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare: function(currentData, newData) {\n        return stableHash(currentData) == stableHash(newData);\n    },\n    isPaused: function() {\n        return false;\n    },\n    cache: cache,\n    mutate: mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\nvar mergeConfigs = function(a, b) {\n    // Need to create a new object to avoid mutating the original here.\n    var v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        var u1 = a.use, f1 = a.fallback;\n        var u2 = b.use, f2 = b.fallback;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\nvar SWRConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar SWRConfig$1 = function(props) {\n    var value = props.value;\n    // Extend parent context values and middleware.\n    var extendedConfig = mergeConfigs((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext), value);\n    // Should not use the inherited provider.\n    var provider = value && value.provider;\n    // Use a lazy initialized state to create the cache on first access.\n    var cacheContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return provider ? initCache(provider(extendedConfig.cache || cache), value) : UNDEFINED;\n    })[0];\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(function() {\n        return cacheContext ? cacheContext[2] : UNDEFINED;\n    }, []);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n/**\n * An implementation of state with dependency-tracking.\n */ var useStateWithDeps = function(state, unmountedRef) {\n    var rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    var stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n     * @param payload To change stateRef, pass the values explicitly to setState:\n     * @example\n     * ```js\n     * setState({\n     *   isValidating: false\n     *   data: newData // set data to newData\n     *   error: undefined // set error to undefined\n     * })\n     *\n     * setState({\n     *   isValidating: false\n     *   data: undefined // set data to undefined\n     *   error: err // set error to err\n     * })\n     * ```\n     */ var setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(payload) {\n        var shouldRerender = false;\n        var currentState = stateRef.current;\n        for(var _ in payload){\n            var k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, // config.suspense isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update the state reference.\n    useIsomorphicLayoutEffect(function() {\n        stateRef.current = state;\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\nvar normalize = function(args) {\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\nvar useSWRConfig = function() {\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nvar withArgs = function(hook) {\n    return function useSWRArgs() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        // Get the default and inherited configuration.\n        var fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        var _a = normalize(args), key = _a[0], fn = _a[1], _config = _a[2];\n        // Merge configurations.\n        var config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        var next = hook;\n        var use = config.use;\n        if (use) {\n            for(var i = use.length; i-- > 0;){\n                next = use[i](next);\n            }\n        }\n        return next(key, fn || config.fetcher, config);\n    };\n};\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nvar subscribeCallback = function(key, callbacks, callback) {\n    var keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return function() {\n        var index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\nvar WITH_DEDUPE = {\n    dedupe: true\n};\nvar useSWRHandler = function(_key, fetcher, config) {\n    var cache = config.cache, compare = config.compare, fallbackData = config.fallbackData, suspense = config.suspense, revalidateOnMount = config.revalidateOnMount, refreshInterval = config.refreshInterval, refreshWhenHidden = config.refreshWhenHidden, refreshWhenOffline = config.refreshWhenOffline;\n    var _a = SWRGlobalState.get(cache), EVENT_REVALIDATORS = _a[0], STATE_UPDATERS = _a[1], MUTATION = _a[2], FETCH = _a[3];\n    // `key` is the identifier of the SWR `data` state, `keyInfo` holds extra\n    // states such as `error` and `isValidating` inside,\n    // all of them are derived from `_key`.\n    // `fnArgs` is an array of arguments parsed from the key, which will be passed\n    // to the fetcher.\n    var _b = serialize(_key), key = _b[0], fnArgs = _b[1], keyInfo = _b[2];\n    // If it's the initial render of this hook.\n    var initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    var unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    var keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    var fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    var configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    var getConfig = function() {\n        return configRef.current;\n    };\n    var isActive = function() {\n        return getConfig().isVisible() && getConfig().isOnline();\n    };\n    var patchFetchInfo = function(info) {\n        return cache.set(keyInfo, mergeObjects(cache.get(keyInfo), info));\n    };\n    // Get the current state that SWR should return.\n    var cached = cache.get(key);\n    var fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;\n    var data = isUndefined(cached) ? fallback : cached;\n    var info = cache.get(keyInfo) || {};\n    var error = info.error;\n    var isInitialMount = !initialMountedRef.current;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    var shouldRevalidate = function() {\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately on mount again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return isUndefined(data) ? false : config.revalidateIfStale;\n        // If there is no stale data, we need to revalidate on mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return isUndefined(data) || config.revalidateIfStale;\n    };\n    // Resolve the current validating state.\n    var resolveValidating = function() {\n        if (!key || !fetcher) return false;\n        if (info.isValidating) return true;\n        // If it's not mounted yet and it should revalidate on mount, revalidate.\n        return isInitialMount && shouldRevalidate();\n    };\n    var isValidating = resolveValidating();\n    var _c = useStateWithDeps({\n        data: data,\n        error: error,\n        isValidating: isValidating\n    }, unmountedRef), stateRef = _c[0], stateDependencies = _c[1], setState = _c[2];\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    var revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(revalidateOpts) {\n        return __awaiter(void 0, void 0, void 0, function() {\n            var currentFetcher, newData, startAt, loading, opts, shouldStartNewRequest, isCurrentKeyMounted, cleanupState, newState, finishRequestAndUpdateState, mutationInfo, err_1;\n            var _a;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        currentFetcher = fetcherRef.current;\n                        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        loading = true;\n                        opts = revalidateOpts || {};\n                        shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n                        isCurrentKeyMounted = function() {\n                            return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n                        };\n                        cleanupState = function() {\n                            // Check if it's still the same request before deleting.\n                            var requestInfo = FETCH[key];\n                            if (requestInfo && requestInfo[1] === startAt) {\n                                delete FETCH[key];\n                            }\n                        };\n                        newState = {\n                            isValidating: false\n                        };\n                        finishRequestAndUpdateState = function() {\n                            patchFetchInfo({\n                                isValidating: false\n                            });\n                            // We can only set state if it's safe (still mounted with the same key).\n                            if (isCurrentKeyMounted()) {\n                                setState(newState);\n                            }\n                        };\n                        // Start fetching. Change the `isValidating` state, update the cache.\n                        patchFetchInfo({\n                            isValidating: true\n                        });\n                        setState({\n                            isValidating: true\n                        });\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([\n                            1,\n                            3,\n                            ,\n                            4\n                        ]);\n                        if (shouldStartNewRequest) {\n                            // Tell all other hooks to change the `isValidating` state.\n                            broadcastState(cache, key, stateRef.current.data, stateRef.current.error, true);\n                            // If no cache being rendered currently (it shows a blank page),\n                            // we trigger the loading slow event.\n                            if (config.loadingTimeout && !cache.get(key)) {\n                                setTimeout(function() {\n                                    if (loading && isCurrentKeyMounted()) {\n                                        getConfig().onLoadingSlow(key, config);\n                                    }\n                                }, config.loadingTimeout);\n                            }\n                            // Start the request and save the timestamp.\n                            FETCH[key] = [\n                                currentFetcher.apply(void 0, fnArgs),\n                                getTimestamp()\n                            ];\n                        }\n                        _a = FETCH[key], newData = _a[0], startAt = _a[1];\n                        return [\n                            4 /*yield*/ ,\n                            newData\n                        ];\n                    case 2:\n                        newData = _b.sent();\n                        if (shouldStartNewRequest) {\n                            // If the request isn't interrupted, clean it up after the\n                            // deduplication interval.\n                            setTimeout(cleanupState, config.dedupingInterval);\n                        }\n                        // If there're other ongoing request(s), started after the current one,\n                        // we need to ignore the current one to avoid possible race conditions:\n                        //   req1------------------>res1        (current one)\n                        //        req2---------------->res2\n                        // the request that fired later will always be kept.\n                        // The timestamp maybe be `undefined` or a number\n                        if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                            if (shouldStartNewRequest) {\n                                if (isCurrentKeyMounted()) {\n                                    getConfig().onDiscarded(key);\n                                }\n                            }\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        // Clear error.\n                        patchFetchInfo({\n                            error: UNDEFINED\n                        });\n                        newState.error = UNDEFINED;\n                        mutationInfo = MUTATION[key];\n                        if (!isUndefined(mutationInfo) && // case 1\n                        (startAt <= mutationInfo[0] || // case 2\n                        startAt <= mutationInfo[1] || // case 3\n                        mutationInfo[1] === 0)) {\n                            finishRequestAndUpdateState();\n                            if (shouldStartNewRequest) {\n                                if (isCurrentKeyMounted()) {\n                                    getConfig().onDiscarded(key);\n                                }\n                            }\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        // Deep compare with latest state to avoid extra re-renders.\n                        // For local state, compare and assign.\n                        if (!compare(stateRef.current.data, newData)) {\n                            newState.data = newData;\n                        } else {\n                            // data and newData are deeply equal\n                            // it should be safe to broadcast the stale data\n                            newState.data = stateRef.current.data;\n                        // At the end of this function, `brocastState` invokes the `onStateUpdate` function,\n                        // which takes care of avoiding the re-render\n                        }\n                        // For global state, it's possible that the key has changed.\n                        // https://github.com/vercel/swr/pull/1058\n                        if (!compare(cache.get(key), newData)) {\n                            cache.set(key, newData);\n                        }\n                        // Trigger the successful callback if it's the original request.\n                        if (shouldStartNewRequest) {\n                            if (isCurrentKeyMounted()) {\n                                getConfig().onSuccess(newData, key, config);\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 3:\n                        err_1 = _b.sent();\n                        cleanupState();\n                        // Not paused, we continue handling the error. Otherwise discard it.\n                        if (!getConfig().isPaused()) {\n                            // Get a new error, don't use deep comparison for errors.\n                            patchFetchInfo({\n                                error: err_1\n                            });\n                            newState.error = err_1;\n                            // Error event and retry logic. Only for the actual request, not\n                            // deduped ones.\n                            if (shouldStartNewRequest && isCurrentKeyMounted()) {\n                                getConfig().onError(err_1, key, config);\n                                if (typeof config.shouldRetryOnError === \"boolean\" && config.shouldRetryOnError || isFunction(config.shouldRetryOnError) && config.shouldRetryOnError(err_1)) {\n                                    // When retrying, dedupe is always enabled\n                                    if (isActive()) {\n                                        // If it's active, stop. It will auto revalidate when refocusing\n                                        // or reconnecting.\n                                        getConfig().onErrorRetry(err_1, key, config, revalidate, {\n                                            retryCount: (opts.retryCount || 0) + 1,\n                                            dedupe: true\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                    case 4:\n                        // Mark loading as stopped.\n                        loading = false;\n                        // Update the current hook's state.\n                        finishRequestAndUpdateState();\n                        // Here is the source of the request, need to tell all other hooks to\n                        // update their states.\n                        if (isCurrentKeyMounted() && shouldStartNewRequest) {\n                            broadcastState(cache, key, newState.data, newState.error, false);\n                        }\n                        return [\n                            2 /*return*/ ,\n                            true\n                        ];\n                }\n            });\n        });\n    }, // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyInfo`,\n    // and `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key\n    ]);\n    // Similar to the global mutate, but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    var boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// By using `bind` we don't need to modify the size of the rest arguments.\n    // Due to https://github.com/microsoft/TypeScript/issues/37181, we have to\n    // cast it to any for now.\n    internalMutate.bind(UNDEFINED, cache, function() {\n        return keyRef.current;\n    }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // Always update fetcher and config refs.\n    useIsomorphicLayoutEffect(function() {\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n    });\n    // After mounted or key changed.\n    useIsomorphicLayoutEffect(function() {\n        if (!key) return;\n        var keyChanged = key !== keyRef.current;\n        var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);\n        // Expose state updater to global event listeners. So we can update hook's\n        // internal state from the outside.\n        var onStateUpdate = function(updatedData, updatedError, updatedIsValidating) {\n            setState(mergeObjects({\n                error: updatedError,\n                isValidating: updatedIsValidating\n            }, // Since `setState` only shallowly compares states, we do a deep\n            // comparison here.\n            compare(stateRef.current.data, updatedData) ? UNDEFINED : {\n                data: updatedData\n            }));\n        };\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        var nextFocusRevalidatedAt = 0;\n        var onRevalidate = function(type) {\n            if (type == FOCUS_EVENT) {\n                var now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == MUTATE_EVENT) {\n                return revalidate();\n            }\n            return;\n        };\n        var unsubUpdate = subscribeCallback(key, STATE_UPDATERS, onStateUpdate);\n        var unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // When `key` updates, reset the state to the initial value\n        // and trigger a rerender if necessary.\n        if (keyChanged) {\n            setState({\n                data: data,\n                error: error,\n                isValidating: isValidating\n            });\n        }\n        // Trigger a revalidation.\n        if (shouldRevalidate()) {\n            if (isUndefined(data) || IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                rAF(softRevalidate);\n            }\n        }\n        return function() {\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubUpdate();\n            unsubEvents();\n        };\n    }, [\n        key,\n        revalidate\n    ]);\n    // Polling\n    useIsomorphicLayoutEffect(function() {\n        var timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            var interval = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval;\n            // We only start next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online and not errored.\n            if (!stateRef.current.error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule next interval to check again.\n                next();\n            }\n        }\n        next();\n        return function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        revalidate\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && isUndefined(data) && key) {\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return data;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        }\n    };\n};\nvar SWRConfig = OBJECT.defineProperty(SWRConfig$1, \"default\", {\n    value: defaultConfig\n});\nvar unstable_serialize = function(key) {\n    return serialize(key)[0];\n};\nvar useSWR = withArgs(useSWRHandler);\n// useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEySTtBQUUzSTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsU0FBU1MsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU08sWUFBWWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDOUIsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTUEsQ0FBQyxDQUFDLEVBQUU7WUFBRSxPQUFPQSxDQUFDLENBQUMsRUFBRTtRQUFFO1FBQUdDLE1BQU0sRUFBRTtRQUFFQyxLQUFLLEVBQUU7SUFBQyxHQUFHQyxHQUFHQyxHQUFHSixHQUFHSztJQUMvRyxPQUFPQSxJQUFJO1FBQUVqQixNQUFNa0IsS0FBSztRQUFJLFNBQVNBLEtBQUs7UUFBSSxVQUFVQSxLQUFLO0lBQUcsR0FBRyxPQUFPQyxXQUFXLGNBQWVGLENBQUFBLENBQUMsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFBYSxPQUFPLElBQUk7SUFBRSxJQUFJSDtJQUN2SixTQUFTQyxLQUFLRyxDQUFDO1FBQUksT0FBTyxTQUFVQyxDQUFDO1lBQUksT0FBT3ZCLEtBQUs7Z0JBQUNzQjtnQkFBR0M7YUFBRTtRQUFHO0lBQUc7SUFDakUsU0FBU3ZCLEtBQUt3QixFQUFFO1FBQ1osSUFBSVIsR0FBRyxNQUFNLElBQUlTLFVBQVU7UUFDM0IsTUFBT2YsRUFBRyxJQUFJO1lBQ1YsSUFBSU0sSUFBSSxHQUFHQyxLQUFNSixDQUFBQSxJQUFJVyxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUlQLENBQUMsQ0FBQyxTQUFTLEdBQUdPLEVBQUUsQ0FBQyxFQUFFLEdBQUdQLENBQUMsQ0FBQyxRQUFRLElBQUssRUFBQ0osSUFBSUksQ0FBQyxDQUFDLFNBQVMsS0FBS0osRUFBRWEsSUFBSSxDQUFDVCxJQUFJLEtBQUtBLEVBQUVoQixJQUFJLEtBQUssQ0FBQyxDQUFDWSxJQUFJQSxFQUFFYSxJQUFJLENBQUNULEdBQUdPLEVBQUUsQ0FBQyxFQUFFLEdBQUduQixJQUFJLEVBQUUsT0FBT1E7WUFDM0osSUFBSUksSUFBSSxHQUFHSixHQUFHVyxLQUFLO2dCQUFDQSxFQUFFLENBQUMsRUFBRSxHQUFHO2dCQUFHWCxFQUFFbEIsS0FBSzthQUFDO1lBQ3ZDLE9BQVE2QixFQUFFLENBQUMsRUFBRTtnQkFDVCxLQUFLO2dCQUFHLEtBQUs7b0JBQUdYLElBQUlXO29CQUFJO2dCQUN4QixLQUFLO29CQUFHZCxFQUFFQyxLQUFLO29CQUFJLE9BQU87d0JBQUVoQixPQUFPNkIsRUFBRSxDQUFDLEVBQUU7d0JBQUVuQixNQUFNO29CQUFNO2dCQUN0RCxLQUFLO29CQUFHSyxFQUFFQyxLQUFLO29CQUFJTSxJQUFJTyxFQUFFLENBQUMsRUFBRTtvQkFBRUEsS0FBSzt3QkFBQztxQkFBRTtvQkFBRTtnQkFDeEMsS0FBSztvQkFBR0EsS0FBS2QsRUFBRUssR0FBRyxDQUFDWSxHQUFHO29CQUFJakIsRUFBRUksSUFBSSxDQUFDYSxHQUFHO29CQUFJO2dCQUN4QztvQkFDSSxJQUFJLENBQUVkLENBQUFBLElBQUlILEVBQUVJLElBQUksRUFBRUQsSUFBSUEsRUFBRWUsTUFBTSxHQUFHLEtBQUtmLENBQUMsQ0FBQ0EsRUFBRWUsTUFBTSxHQUFHLEVBQUUsS0FBTUosQ0FBQUEsRUFBRSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxFQUFFLENBQUMsRUFBRSxLQUFLLElBQUk7d0JBQUVkLElBQUk7d0JBQUc7b0JBQVU7b0JBQzNHLElBQUljLEVBQUUsQ0FBQyxFQUFFLEtBQUssS0FBTSxFQUFDWCxLQUFNVyxFQUFFLENBQUMsRUFBRSxHQUFHWCxDQUFDLENBQUMsRUFBRSxJQUFJVyxFQUFFLENBQUMsRUFBRSxHQUFHWCxDQUFDLENBQUMsRUFBRSxHQUFJO3dCQUFFSCxFQUFFQyxLQUFLLEdBQUdhLEVBQUUsQ0FBQyxFQUFFO3dCQUFFO29CQUFPO29CQUNyRixJQUFJQSxFQUFFLENBQUMsRUFBRSxLQUFLLEtBQUtkLEVBQUVDLEtBQUssR0FBR0UsQ0FBQyxDQUFDLEVBQUUsRUFBRTt3QkFBRUgsRUFBRUMsS0FBSyxHQUFHRSxDQUFDLENBQUMsRUFBRTt3QkFBRUEsSUFBSVc7d0JBQUk7b0JBQU87b0JBQ3BFLElBQUlYLEtBQUtILEVBQUVDLEtBQUssR0FBR0UsQ0FBQyxDQUFDLEVBQUUsRUFBRTt3QkFBRUgsRUFBRUMsS0FBSyxHQUFHRSxDQUFDLENBQUMsRUFBRTt3QkFBRUgsRUFBRUssR0FBRyxDQUFDYyxJQUFJLENBQUNMO3dCQUFLO29CQUFPO29CQUNsRSxJQUFJWCxDQUFDLENBQUMsRUFBRSxFQUFFSCxFQUFFSyxHQUFHLENBQUNZLEdBQUc7b0JBQ25CakIsRUFBRUksSUFBSSxDQUFDYSxHQUFHO29CQUFJO1lBQ3RCO1lBQ0FILEtBQUtmLEtBQUtpQixJQUFJLENBQUNwQyxTQUFTb0I7UUFDNUIsRUFBRSxPQUFPUixHQUFHO1lBQUVzQixLQUFLO2dCQUFDO2dCQUFHdEI7YUFBRTtZQUFFZSxJQUFJO1FBQUcsU0FBVTtZQUFFRCxJQUFJSCxJQUFJO1FBQUc7UUFDekQsSUFBSVcsRUFBRSxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU1BLEVBQUUsQ0FBQyxFQUFFO1FBQUUsT0FBTztZQUFFN0IsT0FBTzZCLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxFQUFFLEdBQUcsS0FBSztZQUFHbkIsTUFBTTtRQUFLO0lBQ25GO0FBQ0o7QUFFQSxJQUFJeUIsT0FBTyxZQUFjO0FBQ3pCLDRFQUE0RTtBQUM1RSwrRUFBK0U7QUFDL0UsOERBQThEO0FBQzlELGtCQUFrQjtBQUNsQixJQUFJQyxZQUFjLGVBQWUsR0FBRUQ7QUFDbkMsSUFBSUUsU0FBU0M7QUFDYixJQUFJQyxjQUFjLFNBQVVYLENBQUM7SUFBSSxPQUFPQSxNQUFNUTtBQUFXO0FBQ3pELElBQUlJLGFBQWEsU0FBVVosQ0FBQztJQUFJLE9BQU8sT0FBT0EsS0FBSztBQUFZO0FBQy9ELElBQUlhLGVBQWUsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksT0FBT04sT0FBT08sTUFBTSxDQUFDLENBQUMsR0FBR0YsR0FBR0M7QUFBSTtBQUNyRSxJQUFJRSxnQkFBZ0I7QUFDcEIsOEZBQThGO0FBQzlGLElBQUlDLFlBQVk7SUFBYyxPQUFPLGVBQWlCRDtBQUFlO0FBQ3JFLElBQUlFLGNBQWM7SUFBYyxPQUFPLE9BQU9DLFlBQVlIO0FBQWU7QUFDekUsSUFBSUksMkJBQTJCO0lBQzNCLE9BQU9ILGVBQWUsT0FBT0ksTUFBTSxDQUFDLHdCQUF3QixJQUFJTDtBQUNwRTtBQUVBLCtDQUErQztBQUMvQywyQ0FBMkM7QUFDM0MseURBQXlEO0FBQ3pELDZCQUE2QjtBQUM3QixJQUFJTSxRQUFRLElBQUlDO0FBQ2hCLHFCQUFxQjtBQUNyQixJQUFJQyxVQUFVO0FBQ2QsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1QyxrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0YsK0VBQStFO0FBQy9FLFlBQVk7QUFDWixJQUFJQyxhQUFhLFNBQVVDLEdBQUc7SUFDMUIsSUFBSUMsT0FBTyxPQUFPRDtJQUNsQixJQUFJRSxjQUFjRixPQUFPQSxJQUFJRSxXQUFXO0lBQ3hDLElBQUlDLFNBQVNELGVBQWVFO0lBQzVCLElBQUlsRDtJQUNKLElBQUltRDtJQUNKLElBQUl2QixPQUFPa0IsU0FBU0EsT0FBTyxDQUFDRyxVQUFVRCxlQUFlSSxRQUFRO1FBQ3pELDRFQUE0RTtRQUM1RSxzREFBc0Q7UUFDdERwRCxTQUFTMEMsTUFBTVcsR0FBRyxDQUFDUDtRQUNuQixJQUFJOUMsUUFDQSxPQUFPQTtRQUNYLDRFQUE0RTtRQUM1RSxnQ0FBZ0M7UUFDaEMsMkVBQTJFO1FBQzNFQSxTQUFTLEVBQUU0QyxVQUFVO1FBQ3JCRixNQUFNWSxHQUFHLENBQUNSLEtBQUs5QztRQUNmLElBQUlnRCxlQUFlTyxPQUFPO1lBQ3RCLFNBQVM7WUFDVHZELFNBQVM7WUFDVCxJQUFLbUQsUUFBUSxHQUFHQSxRQUFRTCxJQUFJdEIsTUFBTSxFQUFFMkIsUUFBUztnQkFDekNuRCxVQUFVNkMsV0FBV0MsR0FBRyxDQUFDSyxNQUFNLElBQUk7WUFDdkM7WUFDQVQsTUFBTVksR0FBRyxDQUFDUixLQUFLOUM7UUFDbkI7UUFDQSxJQUFJZ0QsZUFBZXBCLFFBQVE7WUFDdkIscUJBQXFCO1lBQ3JCNUIsU0FBUztZQUNULElBQUl3RCxPQUFPNUIsT0FBTzRCLElBQUksQ0FBQ1YsS0FBS1csSUFBSTtZQUNoQyxNQUFPLENBQUMzQixZQUFhcUIsUUFBUUssS0FBS2pDLEdBQUcsSUFBTTtnQkFDdkMsSUFBSSxDQUFDTyxZQUFZZ0IsR0FBRyxDQUFDSyxNQUFNLEdBQUc7b0JBQzFCbkQsVUFBVW1ELFFBQVEsTUFBTU4sV0FBV0MsR0FBRyxDQUFDSyxNQUFNLElBQUk7Z0JBQ3JEO1lBQ0o7WUFDQVQsTUFBTVksR0FBRyxDQUFDUixLQUFLOUM7UUFDbkI7SUFDSixPQUNLO1FBQ0RBLFNBQVNpRCxTQUNISCxJQUFJWSxNQUFNLEtBQ1ZYLFFBQVEsV0FDSkQsSUFBSWEsUUFBUSxLQUNaWixRQUFRLFdBQ0phLEtBQUtDLFNBQVMsQ0FBQ2YsT0FDZixLQUFLQTtJQUN2QjtJQUNBLE9BQU85QztBQUNYO0FBRUE7Ozs7OztDQU1DLEdBQ0QsSUFBSThELFNBQVM7QUFDYixJQUFJQyxXQUFXO0lBQWMsT0FBT0Q7QUFBUTtBQUM1QyxJQUFJRSxTQUFTM0I7QUFDYixJQUFJNEIsU0FBUzNCO0FBQ2IsZ0ZBQWdGO0FBQ2hGLElBQUk0QixnQkFBZ0JGLFVBQVV2QixPQUFPMEIsZ0JBQWdCLEdBQy9DMUIsT0FBTzBCLGdCQUFnQixDQUFDQyxJQUFJLENBQUMzQixVQUM3QmY7QUFDTixJQUFJMkMsa0JBQWtCSixTQUFTMUIsU0FBUzRCLGdCQUFnQixDQUFDQyxJQUFJLENBQUM3QixZQUFZYjtBQUMxRSxJQUFJNEMsaUJBQWlCTixVQUFVdkIsT0FBTzhCLG1CQUFtQixHQUNuRDlCLE9BQU84QixtQkFBbUIsQ0FBQ0gsSUFBSSxDQUFDM0IsVUFDaENmO0FBQ04sSUFBSThDLG1CQUFtQlAsU0FDakIxQixTQUFTZ0MsbUJBQW1CLENBQUNILElBQUksQ0FBQzdCLFlBQ2xDYjtBQUNOLElBQUkrQyxZQUFZO0lBQ1osSUFBSUMsa0JBQWtCVCxVQUFVMUIsU0FBU21DLGVBQWU7SUFDeEQsT0FBTzVDLFlBQVk0QyxvQkFBb0JBLG9CQUFvQjtBQUMvRDtBQUNBLElBQUlDLFlBQVksU0FBVUMsUUFBUTtJQUM5QixtQkFBbUI7SUFDbkJQLGdCQUFnQixvQkFBb0JPO0lBQ3BDVixjQUFjLFNBQVNVO0lBQ3ZCLE9BQU87UUFDSEosaUJBQWlCLG9CQUFvQkk7UUFDckNOLGVBQWUsU0FBU007SUFDNUI7QUFDSjtBQUNBLElBQUlDLGdCQUFnQixTQUFVRCxRQUFRO0lBQ2xDLDRCQUE0QjtJQUM1QixJQUFJRSxXQUFXO1FBQ1hoQixTQUFTO1FBQ1RjO0lBQ0o7SUFDQSxnREFBZ0Q7SUFDaEQsSUFBSUcsWUFBWTtRQUNaakIsU0FBUztJQUNiO0lBQ0FJLGNBQWMsVUFBVVk7SUFDeEJaLGNBQWMsV0FBV2E7SUFDekIsT0FBTztRQUNIVCxlQUFlLFVBQVVRO1FBQ3pCUixlQUFlLFdBQVdTO0lBQzlCO0FBQ0o7QUFDQSxJQUFJQyxTQUFTO0lBQ1RqQixVQUFVQTtJQUNWVSxXQUFXQTtBQUNmO0FBQ0EsSUFBSVEsdUJBQXVCO0lBQ3ZCTixXQUFXQTtJQUNYRSxlQUFlQTtBQUNuQjtBQUVBLElBQUlLLFlBQVksQ0FBQzdDLGVBQWUsVUFBVUk7QUFDMUMsaUNBQWlDO0FBQ2pDLElBQUkwQyxNQUFNLFNBQVV2RSxDQUFDO0lBQ2pCLE9BQU80Qiw2QkFBNkJDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQzdCLEtBQUt3RSxXQUFXeEUsR0FBRztBQUMzRjtBQUNBLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0Usa0NBQWtDO0FBQ2xDLElBQUl5RSw0QkFBNEJILFlBQVkxRyw0Q0FBU0EsR0FBR0Msa0RBQWVBO0FBQ3ZFLHdFQUF3RTtBQUN4RSxJQUFJNkcsc0JBQXNCLE9BQU9DLGNBQWMsZUFDM0NBLFVBQVVDLFVBQVU7QUFDeEIsaUVBQWlFO0FBQ2pFLElBQUlDLGlCQUFpQixDQUFDUCxhQUNsQkksdUJBQ0M7SUFBQztJQUFXO0NBQUssQ0FBQ0ksUUFBUSxDQUFDSixvQkFBb0JLLGFBQWEsS0FDekRMLG9CQUFvQk0sUUFBUTtBQUVwQyxJQUFJQyxZQUFZLFNBQVVDLEdBQUc7SUFDekIsSUFBSS9ELFdBQVcrRCxNQUFNO1FBQ2pCLElBQUk7WUFDQUEsTUFBTUE7UUFDVixFQUNBLE9BQU9DLEtBQUs7WUFDUix5QkFBeUI7WUFDekJELE1BQU07UUFDVjtJQUNKO0lBQ0EsSUFBSUUsT0FBTyxFQUFFLENBQUNDLE1BQU0sQ0FBQ0g7SUFDckIsdURBQXVEO0lBQ3ZEQSxNQUNJLE9BQU9BLE9BQU8sV0FDUkEsTUFDQSxDQUFDdkMsTUFBTTJDLE9BQU8sQ0FBQ0osT0FBT0EsSUFBSXRFLE1BQU0sR0FBR3NFLEdBQUUsSUFDakNqRCxXQUFXaUQsT0FDWDtJQUNkLElBQUlLLFVBQVVMLE1BQU0sVUFBVUEsTUFBTTtJQUNwQyxPQUFPO1FBQUNBO1FBQUtFO1FBQU1HO0tBQVE7QUFDL0I7QUFFQSxnRUFBZ0U7QUFDaEUsSUFBSUMsaUJBQWlCLElBQUl6RDtBQUV6QixJQUFJMEQsY0FBYztBQUNsQixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsZUFBZTtBQUVuQixJQUFJQyxpQkFBaUIsU0FBVUMsS0FBSyxFQUFFWCxHQUFHLEVBQUVZLElBQUksRUFBRUMsS0FBSyxFQUFFQyxZQUFZLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUN2RixJQUFJQSxjQUFjLEtBQUssR0FBRztRQUFFQSxZQUFZO0lBQU07SUFDOUMsSUFBSUMsS0FBS1gsZUFBZS9DLEdBQUcsQ0FBQ29ELFFBQVFPLHFCQUFxQkQsRUFBRSxDQUFDLEVBQUUsRUFBRUUsaUJBQWlCRixFQUFFLENBQUMsRUFBRSxFQUFFRyxRQUFRSCxFQUFFLENBQUMsRUFBRTtJQUNyRyxJQUFJSSxlQUFlSCxrQkFBa0IsQ0FBQ2xCLElBQUk7SUFDMUMsSUFBSXNCLFdBQVdILGNBQWMsQ0FBQ25CLElBQUk7SUFDbEMsbURBQW1EO0lBQ25ELElBQUlnQixhQUFhTSxVQUFVO1FBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxTQUFTNUYsTUFBTSxFQUFFLEVBQUU2RixFQUFHO1lBQ3RDRCxRQUFRLENBQUNDLEVBQUUsQ0FBQ1gsTUFBTUMsT0FBT0M7UUFDN0I7SUFDSjtJQUNBLGdFQUFnRTtJQUNoRSxJQUFJQyxZQUFZO1FBQ1osdUVBQXVFO1FBQ3ZFLGdDQUFnQztRQUNoQyxPQUFPSyxLQUFLLENBQUNwQixJQUFJO1FBQ2pCLElBQUlxQixnQkFBZ0JBLFlBQVksQ0FBQyxFQUFFLEVBQUU7WUFDakMsT0FBT0EsWUFBWSxDQUFDLEVBQUUsQ0FBQ1osY0FBY3JHLElBQUksQ0FBQztnQkFDdEMsT0FBT3VHLE1BQU1wRCxHQUFHLENBQUN5QztZQUNyQjtRQUNKO0lBQ0o7SUFDQSxPQUFPVyxNQUFNcEQsR0FBRyxDQUFDeUM7QUFDckI7QUFFQSxvQkFBb0I7QUFDcEIsSUFBSXdCLGNBQWM7QUFDbEIsSUFBSUMsZUFBZTtJQUFjLE9BQU8sRUFBRUQ7QUFBYTtBQUV2RCxJQUFJRSxpQkFBaUI7SUFDakIsSUFBSXhCLE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSXlCLEtBQUssR0FBR0EsS0FBS0MsVUFBVWxHLE1BQU0sRUFBRWlHLEtBQU07UUFDMUN6QixJQUFJLENBQUN5QixHQUFHLEdBQUdDLFNBQVMsQ0FBQ0QsR0FBRztJQUM1QjtJQUNBLE9BQU94SSxVQUFVLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ3JDLElBQUl3SCxPQUFPa0IsTUFBTUMsT0FBT0MsT0FBT0MsU0FBU0MsZUFBZWxCLFlBQVltQixpQkFBaUJDLHNCQUFzQmxCLElBQUlqQixLQUFLb0MsU0FBU0MsSUFBSUMsVUFBVTFCLE1BQU1DLE9BQU8wQixrQkFBa0JDLHlCQUF5QkMsY0FBY0MsZ0JBQWdCQztRQUNoTyxPQUFPckksWUFBWSxJQUFJLEVBQUUsU0FBVXNJLEVBQUU7WUFDakMsT0FBUUEsR0FBR25JLEtBQUs7Z0JBQ1osS0FBSztvQkFDRGtHLFFBQVFULElBQUksQ0FBQyxFQUFFLEVBQUUyQixPQUFPM0IsSUFBSSxDQUFDLEVBQUUsRUFBRTRCLFFBQVE1QixJQUFJLENBQUMsRUFBRSxFQUFFNkIsUUFBUTdCLElBQUksQ0FBQyxFQUFFO29CQUNqRThCLFVBQVUsT0FBT0QsVUFBVSxZQUFZO3dCQUFFaEIsWUFBWWdCO29CQUFNLElBQUlBLFNBQVMsQ0FBQztvQkFDekVFLGdCQUFnQmpHLFlBQVlnRyxRQUFRQyxhQUFhLElBQzNDLE9BQ0FELFFBQVFDLGFBQWE7b0JBQzNCbEIsYUFBYWlCLFFBQVFqQixVQUFVLEtBQUs7b0JBQ3BDbUIsa0JBQWtCRixRQUFRRSxlQUFlLEtBQUs7b0JBQzlDQyx1QkFBdUJILFFBQVFVLGNBQWM7b0JBQzdDekIsS0FBS2xCLFVBQVU4QixPQUFPN0IsTUFBTWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUVtQixVQUFVbkIsRUFBRSxDQUFDLEVBQUU7b0JBQ2xELElBQUksQ0FBQ2pCLEtBQ0QsT0FBTzt3QkFBQyxFQUFFLFFBQVE7cUJBQUc7b0JBQ3pCcUMsS0FBSy9CLGVBQWUvQyxHQUFHLENBQUNvRCxRQUFRMkIsV0FBV0QsRUFBRSxDQUFDLEVBQUU7b0JBQ2hELDJFQUEyRTtvQkFDM0UsSUFBSW5DLEtBQUt4RSxNQUFNLEdBQUcsR0FBRzt3QkFDakIsa0NBQWtDO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSWdGLGVBQWVDLE9BQU9YLEtBQUtXLE1BQU1wRCxHQUFHLENBQUN5QyxNQUFNbkUsV0FBV0EsV0FBV2tGLFlBQVk7eUJBQU07b0JBQzdHO29CQUNBSCxPQUFPa0I7b0JBQ1BTLG1CQUFtQmQ7b0JBQ25CYSxRQUFRLENBQUN0QyxJQUFJLEdBQUc7d0JBQUN1Qzt3QkFBa0I7cUJBQUU7b0JBQ3JDQywwQkFBMEIsQ0FBQ3hHLFlBQVltRztvQkFDdkNNLGVBQWU5QixNQUFNcEQsR0FBRyxDQUFDeUM7b0JBQ3pCLDZCQUE2QjtvQkFDN0IsSUFBSXdDLHlCQUF5Qjt3QkFDekJFLGlCQUFpQnpHLFdBQVdrRyx3QkFDdEJBLHFCQUFxQk0sZ0JBQ3JCTjt3QkFDTnhCLE1BQU1uRCxHQUFHLENBQUN3QyxLQUFLMEM7d0JBQ2ZoQyxlQUFlQyxPQUFPWCxLQUFLMEM7b0JBQy9CO29CQUNBLElBQUl6RyxXQUFXMkUsT0FBTzt3QkFDbEIsNkRBQTZEO3dCQUM3RCxJQUFJOzRCQUNBQSxPQUFPQSxLQUFLRCxNQUFNcEQsR0FBRyxDQUFDeUM7d0JBQzFCLEVBQ0EsT0FBT0MsS0FBSzs0QkFDUixzRUFBc0U7NEJBQ3RFWSxRQUFRWjt3QkFDWjtvQkFDSjtvQkFDQSxJQUFJLENBQUVXLENBQUFBLFFBQVEzRSxXQUFXMkUsS0FBS3hHLElBQUksSUFBSSxPQUFPO3dCQUFDLEVBQUUsT0FBTzt3QkFBSTtxQkFBRTtvQkFDN0QsT0FBTzt3QkFBQyxFQUFFLE9BQU87d0JBQUl3RyxLQUFLaUMsS0FBSyxDQUFDLFNBQVU1QyxHQUFHOzRCQUNyQ1ksUUFBUVo7d0JBQ1o7cUJBSUg7Z0JBQ0wsS0FBSztvQkFDRCx3RUFBd0U7b0JBQ3hFLHlCQUF5QjtvQkFDekJXLE9BQU9nQyxHQUFHbEksSUFBSTtvQkFDZCw0RUFBNEU7b0JBQzVFLG1FQUFtRTtvQkFDbkUsd0JBQXdCO29CQUN4QixJQUFJNkgscUJBQXFCRCxRQUFRLENBQUN0QyxJQUFJLENBQUMsRUFBRSxFQUFFO3dCQUN2QyxJQUFJYSxPQUNBLE1BQU1BO3dCQUNWLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRDt5QkFBSztvQkFDL0IsT0FDSyxJQUFJQyxTQUFTMkIsMkJBQTJCTixpQkFBaUI7d0JBQzFELCtEQUErRDt3QkFDL0QseUJBQXlCO3dCQUN6QkQsZ0JBQWdCO3dCQUNoQnJCLE9BQU82Qjt3QkFDUDlCLE1BQU1uRCxHQUFHLENBQUN3QyxLQUFLeUM7b0JBQ25CO29CQUNBRyxHQUFHbkksS0FBSyxHQUFHO2dCQUNmLEtBQUs7b0JBQ0QsbURBQW1EO29CQUNuRCxJQUFJd0gsZUFBZTt3QkFDZixJQUFJLENBQUNwQixPQUFPOzRCQUNSLGtDQUFrQzs0QkFDbEMsSUFBSTVFLFdBQVdnRyxnQkFBZ0I7Z0NBQzNCckIsT0FBT3FCLGNBQWNyQixNQUFNNkI7NEJBQy9COzRCQUNBLDZFQUE2RTs0QkFDN0U5QixNQUFNbkQsR0FBRyxDQUFDd0MsS0FBS1k7d0JBQ25CO3dCQUNBLG9DQUFvQzt3QkFDcENELE1BQU1uRCxHQUFHLENBQUM0RSxTQUFTbEcsYUFBYXlFLE1BQU1wRCxHQUFHLENBQUM2RSxVQUFVOzRCQUFFdkIsT0FBT0E7d0JBQU07b0JBQ3ZFO29CQUNBLHNEQUFzRDtvQkFDdER5QixRQUFRLENBQUN0QyxJQUFJLENBQUMsRUFBRSxHQUFHeUI7b0JBQ25CLE9BQU87d0JBQUMsRUFBRSxPQUFPO3dCQUFJZixlQUFlQyxPQUFPWCxLQUFLWSxNQUFNQyxPQUFPaEYsV0FBV2tGLFlBQVksQ0FBQyxDQUFDa0I7cUJBRXJGO2dCQUNMLEtBQUs7b0JBQ0RVLE1BQU1DLEdBQUdsSSxJQUFJO29CQUNiLDZCQUE2QjtvQkFDN0IsSUFBSW1HLE9BQ0EsTUFBTUE7b0JBQ1YsT0FBTzt3QkFBQyxFQUFFLFFBQVE7d0JBQUlvQixnQkFBZ0JVLE1BQU0vQjtxQkFBSztZQUN6RDtRQUNKO0lBQ0o7QUFDSjtBQUVBLElBQUlrQyxvQkFBb0IsU0FBVXpCLFlBQVksRUFBRXBFLElBQUk7SUFDaEQsSUFBSyxJQUFJK0MsT0FBT3FCLGFBQWM7UUFDMUIsSUFBSUEsWUFBWSxDQUFDckIsSUFBSSxDQUFDLEVBQUUsRUFDcEJxQixZQUFZLENBQUNyQixJQUFJLENBQUMsRUFBRSxDQUFDL0M7SUFDN0I7QUFDSjtBQUNBLElBQUk4RixZQUFZLFNBQVVDLFFBQVEsRUFBRWhCLE9BQU87SUFDdkMsdUVBQXVFO0lBQ3ZFLDJFQUEyRTtJQUMzRSxhQUFhO0lBQ2IsNkVBQTZFO0lBQzdFLG1EQUFtRDtJQUNuRCxJQUFJLENBQUMxQixlQUFlMkMsR0FBRyxDQUFDRCxXQUFXO1FBQy9CLElBQUlFLE9BQU9oSCxhQUFhaUQsc0JBQXNCNkM7UUFDOUMsOEVBQThFO1FBQzlFLHVCQUF1QjtRQUN2QixJQUFJZCxxQkFBcUIsQ0FBQztRQUMxQixJQUFJaUMsU0FBU3pCLGVBQWVwRCxJQUFJLENBQUN6QyxXQUFXbUg7UUFDNUMsSUFBSUksVUFBVXhIO1FBQ2QsbUVBQW1FO1FBQ25FMEUsZUFBZTlDLEdBQUcsQ0FBQ3dGLFVBQVU7WUFBQzlCO1lBQW9CLENBQUM7WUFBRyxDQUFDO1lBQUcsQ0FBQztZQUFHaUM7U0FBTztRQUNyRSx3RUFBd0U7UUFDeEUsaURBQWlEO1FBQ2pELElBQUksQ0FBQy9ELFdBQVc7WUFDWiw4REFBOEQ7WUFDOUQsdUVBQXVFO1lBQ3ZFLHFFQUFxRTtZQUNyRSx5QkFBeUI7WUFDekIscURBQXFEO1lBQ3JELDZDQUE2QztZQUM3QyxJQUFJaUUsaUJBQWlCSCxLQUFLckUsU0FBUyxDQUFDUyxXQUFXaEIsSUFBSSxDQUFDekMsV0FBV2lILGtCQUFrQnhFLElBQUksQ0FBQ3pDLFdBQVdxRixvQkFBb0JYO1lBQ3JILElBQUkrQyxxQkFBcUJKLEtBQUtuRSxhQUFhLENBQUNPLFdBQVdoQixJQUFJLENBQUN6QyxXQUFXaUgsa0JBQWtCeEUsSUFBSSxDQUFDekMsV0FBV3FGLG9CQUFvQlY7WUFDN0g0QyxVQUFVO2dCQUNOQyxrQkFBa0JBO2dCQUNsQkMsc0JBQXNCQTtnQkFDdEIsd0VBQXdFO2dCQUN4RSx3RUFBd0U7Z0JBQ3hFLDhDQUE4QztnQkFDOUNoRCxlQUFlaUQsTUFBTSxDQUFDUDtZQUMxQjtRQUNKO1FBQ0EsNkVBQTZFO1FBQzdFLDJDQUEyQztRQUMzQyxrRUFBa0U7UUFDbEUsT0FBTztZQUFDQTtZQUFVRztZQUFRQztTQUFRO0lBQ3RDO0lBQ0EsT0FBTztRQUFDSjtRQUFVMUMsZUFBZS9DLEdBQUcsQ0FBQ3lGLFNBQVMsQ0FBQyxFQUFFO0tBQUM7QUFDdEQ7QUFFQSxjQUFjO0FBQ2QsSUFBSVEsZUFBZSxTQUFVaEosQ0FBQyxFQUFFaUosRUFBRSxFQUFFQyxNQUFNLEVBQUUzQyxVQUFVLEVBQUVtQyxJQUFJO0lBQ3hELElBQUlTLGdCQUFnQkQsT0FBT0UsZUFBZTtJQUMxQyxJQUFJQyxvQkFBb0JYLEtBQUtZLFVBQVU7SUFDdkMsc0JBQXNCO0lBQ3RCLElBQUlDLFVBQVUsQ0FBQyxDQUFFLEVBQUNDLEtBQUtDLE1BQU0sS0FBSyxHQUFFLElBQy9CLE1BQU1KLENBQUFBLG9CQUFvQixJQUFJQSxvQkFBb0IsRUFBQyxDQUFDLElBQUtILE9BQU9RLGtCQUFrQjtJQUN2RixJQUFJLENBQUNsSSxZQUFZMkgsa0JBQWtCRSxvQkFBb0JGLGVBQWU7UUFDbEU7SUFDSjtJQUNBckUsV0FBV3lCLFlBQVlnRCxTQUFTYjtBQUNwQztBQUNBLHlCQUF5QjtBQUN6QixJQUFJakMsS0FBSzhCLFVBQVUsSUFBSW9CLFFBQVF4RCxRQUFRTSxFQUFFLENBQUMsRUFBRSxFQUFFa0MsU0FBU2xDLEVBQUUsQ0FBQyxFQUFFO0FBQzVELGlCQUFpQjtBQUNqQixJQUFJbUQsZ0JBQWdCbEksYUFBYTtJQUM3QixTQUFTO0lBQ1RtSSxlQUFlekk7SUFDZjBJLFdBQVcxSTtJQUNYMkksU0FBUzNJO0lBQ1Q0SCxjQUFjQTtJQUNkZ0IsYUFBYTVJO0lBQ2IsV0FBVztJQUNYNkksbUJBQW1CO0lBQ25CQyx1QkFBdUI7SUFDdkJDLG1CQUFtQjtJQUNuQkMsb0JBQW9CO0lBQ3BCLFdBQVc7SUFDWFYsb0JBQW9CdkUsaUJBQWlCLFFBQVE7SUFDN0NrRix1QkFBdUIsSUFBSTtJQUMzQkMsa0JBQWtCLElBQUk7SUFDdEJDLGdCQUFnQnBGLGlCQUFpQixPQUFPO0lBQ3hDLFlBQVk7SUFDWnFGLFNBQVMsU0FBVUMsV0FBVyxFQUFFQyxPQUFPO1FBQ25DLE9BQU9uSSxXQUFXa0ksZ0JBQWdCbEksV0FBV21JO0lBQ2pEO0lBQ0FDLFVBQVU7UUFBYyxPQUFPO0lBQU87SUFDdEN4RSxPQUFPQTtJQUNQd0MsUUFBUUE7SUFDUmlDLFVBQVUsQ0FBQztBQUNmLEdBQ0EsNEJBQTRCO0FBQzVCbEc7QUFFQSxJQUFJbUcsZUFBZSxTQUFVbEosQ0FBQyxFQUFFQyxDQUFDO0lBQzdCLG1FQUFtRTtJQUNuRSxJQUFJZixJQUFJYSxhQUFhQyxHQUFHQztJQUN4Qix5RUFBeUU7SUFDekUsSUFBSUEsR0FBRztRQUNILElBQUlrSixLQUFLbkosRUFBRW9KLEdBQUcsRUFBRUMsS0FBS3JKLEVBQUVpSixRQUFRO1FBQy9CLElBQUlLLEtBQUtySixFQUFFbUosR0FBRyxFQUFFRyxLQUFLdEosRUFBRWdKLFFBQVE7UUFDL0IsSUFBSUUsTUFBTUcsSUFBSTtZQUNWcEssRUFBRWtLLEdBQUcsR0FBR0QsR0FBR25GLE1BQU0sQ0FBQ3NGO1FBQ3RCO1FBQ0EsSUFBSUQsTUFBTUUsSUFBSTtZQUNWckssRUFBRStKLFFBQVEsR0FBR2xKLGFBQWFzSixJQUFJRTtRQUNsQztJQUNKO0lBQ0EsT0FBT3JLO0FBQ1g7QUFFQSxJQUFJc0ssaUNBQW1CL00sb0RBQWFBLENBQUMsQ0FBQztBQUN0QyxJQUFJZ04sY0FBYyxTQUFVQyxLQUFLO0lBQzdCLElBQUlwTSxRQUFRb00sTUFBTXBNLEtBQUs7SUFDdkIsK0NBQStDO0lBQy9DLElBQUlxTSxpQkFBaUJULGFBQWF4TSxpREFBVUEsQ0FBQzhNLG1CQUFtQmxNO0lBQ2hFLHlDQUF5QztJQUN6QyxJQUFJdUosV0FBV3ZKLFNBQVNBLE1BQU11SixRQUFRO0lBQ3RDLG9FQUFvRTtJQUNwRSxJQUFJK0MsZUFBZWpOLCtDQUFRQSxDQUFDO1FBQ3hCLE9BQU9rSyxXQUNERCxVQUFVQyxTQUFTOEMsZUFBZW5GLEtBQUssSUFBSUEsUUFBUWxILFNBQ25Eb0M7SUFDVixFQUFFLENBQUMsRUFBRTtJQUNMLGlEQUFpRDtJQUNqRCxJQUFJa0ssY0FBYztRQUNkRCxlQUFlbkYsS0FBSyxHQUFHb0YsWUFBWSxDQUFDLEVBQUU7UUFDdENELGVBQWUzQyxNQUFNLEdBQUc0QyxZQUFZLENBQUMsRUFBRTtJQUMzQztJQUNBLHNCQUFzQjtJQUN0QnhHLDBCQUEwQjtRQUFjLE9BQVF3RyxlQUFlQSxZQUFZLENBQUMsRUFBRSxHQUFHbEs7SUFBWSxHQUFHLEVBQUU7SUFDbEcscUJBQU85QyxvREFBYUEsQ0FBQzRNLGlCQUFpQkssUUFBUSxFQUFFOUosYUFBYTJKLE9BQU87UUFDaEVwTSxPQUFPcU07SUFDWDtBQUNKO0FBRUE7O0NBRUMsR0FDRCxJQUFJRyxtQkFBbUIsU0FBVUMsS0FBSyxFQUFFQyxZQUFZO0lBQ2hELElBQUlDLFdBQVd0TiwrQ0FBUUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQzlCLElBQUl1TixXQUFXck4sNkNBQU1BLENBQUNrTjtJQUN0Qiw4RUFBOEU7SUFDOUUsMkVBQTJFO0lBQzNFLHdDQUF3QztJQUN4Qyw2Q0FBNkM7SUFDN0MsSUFBSUksdUJBQXVCdE4sNkNBQU1BLENBQUM7UUFDOUI0SCxNQUFNO1FBQ05DLE9BQU87UUFDUEMsY0FBYztJQUNsQjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0QsSUFBSXlGLFdBQVd0TixrREFBV0EsQ0FBQyxTQUFVdU4sT0FBTztRQUN4QyxJQUFJQyxpQkFBaUI7UUFDckIsSUFBSUMsZUFBZUwsU0FBU00sT0FBTztRQUNuQyxJQUFLLElBQUluTSxLQUFLZ00sUUFBUztZQUNuQixJQUFJSSxJQUFJcE07WUFDUixxRUFBcUU7WUFDckUsVUFBVTtZQUNWLElBQUlrTSxZQUFZLENBQUNFLEVBQUUsS0FBS0osT0FBTyxDQUFDSSxFQUFFLEVBQUU7Z0JBQ2hDRixZQUFZLENBQUNFLEVBQUUsR0FBR0osT0FBTyxDQUFDSSxFQUFFO2dCQUM1QixxRUFBcUU7Z0JBQ3JFLGFBQWE7Z0JBQ2IsSUFBSU4scUJBQXFCSyxPQUFPLENBQUNDLEVBQUUsRUFBRTtvQkFDakNILGlCQUFpQjtnQkFDckI7WUFDSjtRQUNKO1FBQ0EsSUFBSUEsa0JBQWtCLENBQUNOLGFBQWFRLE9BQU8sRUFBRTtZQUN6Q1AsU0FBUyxDQUFDO1FBQ2Q7SUFDSixHQUNBLCtEQUErRDtJQUMvRCx1REFBdUQ7SUFDdkQsRUFBRTtJQUNGLHFDQUFxQztJQUNyQzdHLDBCQUEwQjtRQUN0QjhHLFNBQVNNLE9BQU8sR0FBR1Q7SUFDdkI7SUFDQSxPQUFPO1FBQUNHO1FBQVVDLHFCQUFxQkssT0FBTztRQUFFSjtLQUFTO0FBQzdEO0FBRUEsSUFBSU0sWUFBWSxTQUFVM0csSUFBSTtJQUMxQixPQUFPakUsV0FBV2lFLElBQUksQ0FBQyxFQUFFLElBQ25CO1FBQUNBLElBQUksQ0FBQyxFQUFFO1FBQUVBLElBQUksQ0FBQyxFQUFFO1FBQUVBLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQztLQUFFLEdBQ2pDO1FBQUNBLElBQUksQ0FBQyxFQUFFO1FBQUU7UUFBT0EsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsS0FBSyxPQUFPQSxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUM7S0FBRTtBQUN2RTtBQUVBLElBQUk0RyxlQUFlO0lBQ2YsT0FBTzVLLGFBQWFrSSxlQUFldkwsaURBQVVBLENBQUM4TTtBQUNsRDtBQUVBLGdGQUFnRjtBQUNoRixrQkFBa0I7QUFDbEIsSUFBSW9CLFdBQVcsU0FBVUMsSUFBSTtJQUN6QixPQUFPLFNBQVNDO1FBQ1osSUFBSS9HLE9BQU8sRUFBRTtRQUNiLElBQUssSUFBSXlCLEtBQUssR0FBR0EsS0FBS0MsVUFBVWxHLE1BQU0sRUFBRWlHLEtBQU07WUFDMUN6QixJQUFJLENBQUN5QixHQUFHLEdBQUdDLFNBQVMsQ0FBQ0QsR0FBRztRQUM1QjtRQUNBLCtDQUErQztRQUMvQyxJQUFJdUYsaUJBQWlCSjtRQUNyQix1QkFBdUI7UUFDdkIsSUFBSTdGLEtBQUs0RixVQUFVM0csT0FBT0YsTUFBTWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUVrRyxLQUFLbEcsRUFBRSxDQUFDLEVBQUUsRUFBRW1HLFVBQVVuRyxFQUFFLENBQUMsRUFBRTtRQUNsRSx3QkFBd0I7UUFDeEIsSUFBSXlDLFNBQVMyQixhQUFhNkIsZ0JBQWdCRTtRQUMxQyxtQkFBbUI7UUFDbkIsSUFBSXJOLE9BQU9pTjtRQUNYLElBQUl6QixNQUFNN0IsT0FBTzZCLEdBQUc7UUFDcEIsSUFBSUEsS0FBSztZQUNMLElBQUssSUFBSWhFLElBQUlnRSxJQUFJN0osTUFBTSxFQUFFNkYsTUFBTSxHQUFJO2dCQUMvQnhILE9BQU93TCxHQUFHLENBQUNoRSxFQUFFLENBQUN4SDtZQUNsQjtRQUNKO1FBQ0EsT0FBT0EsS0FBS2lHLEtBQUttSCxNQUFNekQsT0FBTzJELE9BQU8sRUFBRTNEO0lBQzNDO0FBQ0o7QUFFQSwyRUFBMkU7QUFDM0UsNEJBQTRCO0FBQzVCLElBQUk0RCxvQkFBb0IsU0FBVXRILEdBQUcsRUFBRXVILFNBQVMsRUFBRXpJLFFBQVE7SUFDdEQsSUFBSTBJLG9CQUFvQkQsU0FBUyxDQUFDdkgsSUFBSSxJQUFLdUgsQ0FBQUEsU0FBUyxDQUFDdkgsSUFBSSxHQUFHLEVBQUU7SUFDOUR3SCxrQkFBa0I3TCxJQUFJLENBQUNtRDtJQUN2QixPQUFPO1FBQ0gsSUFBSXpCLFFBQVFtSyxrQkFBa0JDLE9BQU8sQ0FBQzNJO1FBQ3RDLElBQUl6QixTQUFTLEdBQUc7WUFDWiwyQkFBMkI7WUFDM0JtSyxpQkFBaUIsQ0FBQ25LLE1BQU0sR0FBR21LLGlCQUFpQixDQUFDQSxrQkFBa0I5TCxNQUFNLEdBQUcsRUFBRTtZQUMxRThMLGtCQUFrQi9MLEdBQUc7UUFDekI7SUFDSjtBQUNKO0FBRUEsSUFBSWlNLGNBQWM7SUFBRUMsUUFBUTtBQUFLO0FBQ2pDLElBQUlDLGdCQUFnQixTQUFVL0YsSUFBSSxFQUFFd0YsT0FBTyxFQUFFM0QsTUFBTTtJQUMvQyxJQUFJL0MsUUFBUStDLE9BQU8vQyxLQUFLLEVBQUVxRSxVQUFVdEIsT0FBT3NCLE9BQU8sRUFBRTZDLGVBQWVuRSxPQUFPbUUsWUFBWSxFQUFFQyxXQUFXcEUsT0FBT29FLFFBQVEsRUFBRUMsb0JBQW9CckUsT0FBT3FFLGlCQUFpQixFQUFFQyxrQkFBa0J0RSxPQUFPc0UsZUFBZSxFQUFFQyxvQkFBb0J2RSxPQUFPdUUsaUJBQWlCLEVBQUVDLHFCQUFxQnhFLE9BQU93RSxrQkFBa0I7SUFDeFMsSUFBSWpILEtBQUtYLGVBQWUvQyxHQUFHLENBQUNvRCxRQUFRTyxxQkFBcUJELEVBQUUsQ0FBQyxFQUFFLEVBQUVFLGlCQUFpQkYsRUFBRSxDQUFDLEVBQUUsRUFBRXFCLFdBQVdyQixFQUFFLENBQUMsRUFBRSxFQUFFRyxRQUFRSCxFQUFFLENBQUMsRUFBRTtJQUN2SCx5RUFBeUU7SUFDekUsb0RBQW9EO0lBQ3BELHVDQUF1QztJQUN2Qyw4RUFBOEU7SUFDOUUsa0JBQWtCO0lBQ2xCLElBQUlvQixLQUFLdEMsVUFBVThCLE9BQU83QixNQUFNcUMsRUFBRSxDQUFDLEVBQUUsRUFBRThGLFNBQVM5RixFQUFFLENBQUMsRUFBRSxFQUFFRCxVQUFVQyxFQUFFLENBQUMsRUFBRTtJQUN0RSwyQ0FBMkM7SUFDM0MsSUFBSStGLG9CQUFvQnBQLDZDQUFNQSxDQUFDO0lBQy9CLDhFQUE4RTtJQUM5RSxpQ0FBaUM7SUFDakMsSUFBSW1OLGVBQWVuTiw2Q0FBTUEsQ0FBQztJQUMxQixtQ0FBbUM7SUFDbkMsSUFBSXFQLFNBQVNyUCw2Q0FBTUEsQ0FBQ2dIO0lBQ3BCLElBQUlzSSxhQUFhdFAsNkNBQU1BLENBQUNxTztJQUN4QixJQUFJa0IsWUFBWXZQLDZDQUFNQSxDQUFDMEs7SUFDdkIsSUFBSThFLFlBQVk7UUFBYyxPQUFPRCxVQUFVNUIsT0FBTztJQUFFO0lBQ3hELElBQUk4QixXQUFXO1FBQWMsT0FBT0QsWUFBWTdKLFNBQVMsTUFBTTZKLFlBQVl2SyxRQUFRO0lBQUk7SUFDdkYsSUFBSXlLLGlCQUFpQixTQUFVQyxJQUFJO1FBQy9CLE9BQU9oSSxNQUFNbkQsR0FBRyxDQUFDNEUsU0FBU2xHLGFBQWF5RSxNQUFNcEQsR0FBRyxDQUFDNkUsVUFBVXVHO0lBQy9EO0lBQ0EsZ0RBQWdEO0lBQ2hELElBQUlDLFNBQVNqSSxNQUFNcEQsR0FBRyxDQUFDeUM7SUFDdkIsSUFBSW9GLFdBQVdwSixZQUFZNkwsZ0JBQ3JCbkUsT0FBTzBCLFFBQVEsQ0FBQ3BGLElBQUksR0FDcEI2SDtJQUNOLElBQUlqSCxPQUFPNUUsWUFBWTRNLFVBQVV4RCxXQUFXd0Q7SUFDNUMsSUFBSUQsT0FBT2hJLE1BQU1wRCxHQUFHLENBQUM2RSxZQUFZLENBQUM7SUFDbEMsSUFBSXZCLFFBQVE4SCxLQUFLOUgsS0FBSztJQUN0QixJQUFJZ0ksaUJBQWlCLENBQUNULGtCQUFrQnpCLE9BQU87SUFDL0MsaUVBQWlFO0lBQ2pFLHdGQUF3RjtJQUN4Riw4REFBOEQ7SUFDOUQsSUFBSW1DLG1CQUFtQjtRQUNuQiw2REFBNkQ7UUFDN0QsSUFBSUQsa0JBQWtCLENBQUM3TSxZQUFZK0wsb0JBQy9CLE9BQU9BO1FBQ1gsd0NBQXdDO1FBQ3hDLElBQUlTLFlBQVlyRCxRQUFRLElBQ3BCLE9BQU87UUFDWCxxRUFBcUU7UUFDckUsa0VBQWtFO1FBQ2xFLGtFQUFrRTtRQUNsRSxJQUFJMkMsVUFDQSxPQUFPOUwsWUFBWTRFLFFBQVEsUUFBUThDLE9BQU9pQixpQkFBaUI7UUFDL0QsNkRBQTZEO1FBQzdELG9FQUFvRTtRQUNwRSxPQUFPM0ksWUFBWTRFLFNBQVM4QyxPQUFPaUIsaUJBQWlCO0lBQ3hEO0lBQ0Esd0NBQXdDO0lBQ3hDLElBQUlvRSxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDL0ksT0FBTyxDQUFDcUgsU0FDVCxPQUFPO1FBQ1gsSUFBSXNCLEtBQUs3SCxZQUFZLEVBQ2pCLE9BQU87UUFDWCx5RUFBeUU7UUFDekUsT0FBTytILGtCQUFrQkM7SUFDN0I7SUFDQSxJQUFJaEksZUFBZWlJO0lBQ25CLElBQUluRyxLQUFLcUQsaUJBQWlCO1FBQ3RCckYsTUFBTUE7UUFDTkMsT0FBT0E7UUFDUEMsY0FBY0E7SUFDbEIsR0FBR3FGLGVBQWVFLFdBQVd6RCxFQUFFLENBQUMsRUFBRSxFQUFFb0csb0JBQW9CcEcsRUFBRSxDQUFDLEVBQUUsRUFBRTJELFdBQVczRCxFQUFFLENBQUMsRUFBRTtJQUMvRSwyRUFBMkU7SUFDM0Usc0RBQXNEO0lBQ3RELElBQUk3QixhQUFhOUgsa0RBQVdBLENBQUMsU0FBVWdRLGNBQWM7UUFBSSxPQUFPOVAsVUFBVSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRztZQUM5RixJQUFJK1AsZ0JBQWdCaEUsU0FBU2lFLFNBQVNDLFNBQVNsRyxNQUFNbUcsdUJBQXVCQyxxQkFBcUJDLGNBQWNDLFVBQVVDLDZCQUE2QkMsY0FBY0M7WUFDcEssSUFBSTFJO1lBQ0osT0FBTzNHLFlBQVksSUFBSSxFQUFFLFNBQVUrSCxFQUFFO2dCQUNqQyxPQUFRQSxHQUFHNUgsS0FBSztvQkFDWixLQUFLO3dCQUNEeU8saUJBQWlCWixXQUFXM0IsT0FBTzt3QkFDbkMsSUFBSSxDQUFDM0csT0FDRCxDQUFDa0osa0JBQ0QvQyxhQUFhUSxPQUFPLElBQ3BCNkIsWUFBWXJELFFBQVEsSUFBSTs0QkFDeEIsT0FBTztnQ0FBQyxFQUFFLFFBQVE7Z0NBQUk7NkJBQU07d0JBQ2hDO3dCQUNBaUUsVUFBVTt3QkFDVmxHLE9BQU8rRixrQkFBa0IsQ0FBQzt3QkFDMUJJLHdCQUF3QixDQUFDakksS0FBSyxDQUFDcEIsSUFBSSxJQUFJLENBQUNrRCxLQUFLeUUsTUFBTTt3QkFDbkQyQixzQkFBc0I7NEJBQ2xCLE9BQU8sQ0FBQ25ELGFBQWFRLE9BQU8sSUFDeEIzRyxRQUFRcUksT0FBTzFCLE9BQU8sSUFDdEJ5QixrQkFBa0J6QixPQUFPO3dCQUNqQzt3QkFDQTRDLGVBQWU7NEJBQ1gsd0RBQXdEOzRCQUN4RCxJQUFJSyxjQUFjeEksS0FBSyxDQUFDcEIsSUFBSTs0QkFDNUIsSUFBSTRKLGVBQWVBLFdBQVcsQ0FBQyxFQUFFLEtBQUtULFNBQVM7Z0NBQzNDLE9BQU8vSCxLQUFLLENBQUNwQixJQUFJOzRCQUNyQjt3QkFDSjt3QkFDQXdKLFdBQVc7NEJBQUUxSSxjQUFjO3dCQUFNO3dCQUNqQzJJLDhCQUE4Qjs0QkFDMUJmLGVBQWU7Z0NBQUU1SCxjQUFjOzRCQUFNOzRCQUNyQyx3RUFBd0U7NEJBQ3hFLElBQUl3SSx1QkFBdUI7Z0NBQ3ZCL0MsU0FBU2lEOzRCQUNiO3dCQUNKO3dCQUNBLHFFQUFxRTt3QkFDckVkLGVBQWU7NEJBQ1g1SCxjQUFjO3dCQUNsQjt3QkFDQXlGLFNBQVM7NEJBQUV6RixjQUFjO3dCQUFLO3dCQUM5QnVCLEdBQUc1SCxLQUFLLEdBQUc7b0JBQ2YsS0FBSzt3QkFDRDRILEdBQUd6SCxJQUFJLENBQUNlLElBQUksQ0FBQzs0QkFBQzs0QkFBRzs7NEJBQUs7eUJBQUU7d0JBQ3hCLElBQUkwTix1QkFBdUI7NEJBQ3ZCLDJEQUEyRDs0QkFDM0QzSSxlQUFlQyxPQUFPWCxLQUFLcUcsU0FBU00sT0FBTyxDQUFDL0YsSUFBSSxFQUFFeUYsU0FBU00sT0FBTyxDQUFDOUYsS0FBSyxFQUFFOzRCQUMxRSxnRUFBZ0U7NEJBQ2hFLHFDQUFxQzs0QkFDckMsSUFBSTZDLE9BQU9xQixjQUFjLElBQUksQ0FBQ3BFLE1BQU1wRCxHQUFHLENBQUN5QyxNQUFNO2dDQUMxQ1YsV0FBVztvQ0FDUCxJQUFJOEosV0FBV0UsdUJBQXVCO3dDQUNsQ2QsWUFBWW5FLGFBQWEsQ0FBQ3JFLEtBQUswRDtvQ0FDbkM7Z0NBQ0osR0FBR0EsT0FBT3FCLGNBQWM7NEJBQzVCOzRCQUNBLDRDQUE0Qzs0QkFDNUMzRCxLQUFLLENBQUNwQixJQUFJLEdBQUc7Z0NBQUNrSixlQUFlN08sS0FBSyxDQUFDLEtBQUssR0FBRzhOO2dDQUFTMUc7NkJBQWU7d0JBQ3ZFO3dCQUNBUixLQUFLRyxLQUFLLENBQUNwQixJQUFJLEVBQUVrRixVQUFVakUsRUFBRSxDQUFDLEVBQUUsRUFBRWtJLFVBQVVsSSxFQUFFLENBQUMsRUFBRTt3QkFDakQsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUlpRTt5QkFBUTtvQkFDakMsS0FBSzt3QkFDREEsVUFBVTdDLEdBQUczSCxJQUFJO3dCQUNqQixJQUFJMk8sdUJBQXVCOzRCQUN2QiwwREFBMEQ7NEJBQzFELDBCQUEwQjs0QkFDMUIvSixXQUFXaUssY0FBYzdGLE9BQU9vQixnQkFBZ0I7d0JBQ3BEO3dCQUNBLHVFQUF1RTt3QkFDdkUsdUVBQXVFO3dCQUN2RSxxREFBcUQ7d0JBQ3JELG1DQUFtQzt3QkFDbkMsb0RBQW9EO3dCQUNwRCxpREFBaUQ7d0JBQ2pELElBQUksQ0FBQzFELEtBQUssQ0FBQ3BCLElBQUksSUFBSW9CLEtBQUssQ0FBQ3BCLElBQUksQ0FBQyxFQUFFLEtBQUttSixTQUFTOzRCQUMxQyxJQUFJRSx1QkFBdUI7Z0NBQ3ZCLElBQUlDLHVCQUF1QjtvQ0FDdkJkLFlBQVloRSxXQUFXLENBQUN4RTtnQ0FDNUI7NEJBQ0o7NEJBQ0EsT0FBTztnQ0FBQyxFQUFFLFFBQVE7Z0NBQUk7NkJBQU07d0JBQ2hDO3dCQUNBLGVBQWU7d0JBQ2YwSSxlQUFlOzRCQUNYN0gsT0FBT2hGO3dCQUNYO3dCQUNBMk4sU0FBUzNJLEtBQUssR0FBR2hGO3dCQUNqQjZOLGVBQWVwSCxRQUFRLENBQUN0QyxJQUFJO3dCQUM1QixJQUFJLENBQUNoRSxZQUFZME4saUJBQ2IsU0FBUzt3QkFDUlAsQ0FBQUEsV0FBV08sWUFBWSxDQUFDLEVBQUUsSUFDdkIsU0FBUzt3QkFDVFAsV0FBV08sWUFBWSxDQUFDLEVBQUUsSUFDMUIsU0FBUzt3QkFDVEEsWUFBWSxDQUFDLEVBQUUsS0FBSyxJQUFJOzRCQUM1QkQ7NEJBQ0EsSUFBSUosdUJBQXVCO2dDQUN2QixJQUFJQyx1QkFBdUI7b0NBQ3ZCZCxZQUFZaEUsV0FBVyxDQUFDeEU7Z0NBQzVCOzRCQUNKOzRCQUNBLE9BQU87Z0NBQUMsRUFBRSxRQUFRO2dDQUFJOzZCQUFNO3dCQUNoQzt3QkFDQSw0REFBNEQ7d0JBQzVELHVDQUF1Qzt3QkFDdkMsSUFBSSxDQUFDZ0YsUUFBUXFCLFNBQVNNLE9BQU8sQ0FBQy9GLElBQUksRUFBRXNFLFVBQVU7NEJBQzFDc0UsU0FBUzVJLElBQUksR0FBR3NFO3dCQUNwQixPQUNLOzRCQUNELG9DQUFvQzs0QkFDcEMsZ0RBQWdEOzRCQUNoRHNFLFNBQVM1SSxJQUFJLEdBQUd5RixTQUFTTSxPQUFPLENBQUMvRixJQUFJO3dCQUNyQyxvRkFBb0Y7d0JBQ3BGLDZDQUE2Qzt3QkFDakQ7d0JBQ0EsNERBQTREO3dCQUM1RCwwQ0FBMEM7d0JBQzFDLElBQUksQ0FBQ29FLFFBQVFyRSxNQUFNcEQsR0FBRyxDQUFDeUMsTUFBTWtGLFVBQVU7NEJBQ25DdkUsTUFBTW5ELEdBQUcsQ0FBQ3dDLEtBQUtrRjt3QkFDbkI7d0JBQ0EsZ0VBQWdFO3dCQUNoRSxJQUFJbUUsdUJBQXVCOzRCQUN2QixJQUFJQyx1QkFBdUI7Z0NBQ3ZCZCxZQUFZbEUsU0FBUyxDQUFDWSxTQUFTbEYsS0FBSzBEOzRCQUN4Qzt3QkFDSjt3QkFDQSxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTt5QkFBRTtvQkFDM0IsS0FBSzt3QkFDRGlHLFFBQVF0SCxHQUFHM0gsSUFBSTt3QkFDZjZPO3dCQUNBLG9FQUFvRTt3QkFDcEUsSUFBSSxDQUFDZixZQUFZckQsUUFBUSxJQUFJOzRCQUN6Qix5REFBeUQ7NEJBQ3pEdUQsZUFBZTtnQ0FBRTdILE9BQU84STs0QkFBTTs0QkFDOUJILFNBQVMzSSxLQUFLLEdBQUc4STs0QkFDakIsZ0VBQWdFOzRCQUNoRSxnQkFBZ0I7NEJBQ2hCLElBQUlOLHlCQUF5QkMsdUJBQXVCO2dDQUNoRGQsWUFBWWpFLE9BQU8sQ0FBQ29GLE9BQU8zSixLQUFLMEQ7Z0NBQ2hDLElBQUksT0FBUUEsT0FBT2tCLGtCQUFrQixLQUFLLGFBQ3RDbEIsT0FBT2tCLGtCQUFrQixJQUN4QjNJLFdBQVd5SCxPQUFPa0Isa0JBQWtCLEtBQ2pDbEIsT0FBT2tCLGtCQUFrQixDQUFDK0UsUUFBUztvQ0FDdkMsMENBQTBDO29DQUMxQyxJQUFJbEIsWUFBWTt3Q0FDWixnRUFBZ0U7d0NBQ2hFLG1CQUFtQjt3Q0FDbkJELFlBQVloRixZQUFZLENBQUNtRyxPQUFPM0osS0FBSzBELFFBQVEzQyxZQUFZOzRDQUNyRCtDLFlBQVksQ0FBQ1osS0FBS1ksVUFBVSxJQUFJLEtBQUs7NENBQ3JDNkQsUUFBUTt3Q0FDWjtvQ0FDSjtnQ0FDSjs0QkFDSjt3QkFDSjt3QkFDQSxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTt5QkFBRTtvQkFDM0IsS0FBSzt3QkFDRCwyQkFBMkI7d0JBQzNCeUIsVUFBVTt3QkFDVixtQ0FBbUM7d0JBQ25DSzt3QkFDQSxxRUFBcUU7d0JBQ3JFLHVCQUF1Qjt3QkFDdkIsSUFBSUgseUJBQXlCRCx1QkFBdUI7NEJBQ2hEM0ksZUFBZUMsT0FBT1gsS0FBS3dKLFNBQVM1SSxJQUFJLEVBQUU0SSxTQUFTM0ksS0FBSyxFQUFFO3dCQUM5RDt3QkFDQSxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSTt5QkFBSztnQkFDbkM7WUFDSjtRQUNKO0lBQUksR0FDSixzRUFBc0U7SUFDdEUsMEVBQTBFO0lBQzFFLGtCQUFrQjtJQUNsQixFQUFFO0lBQ0YsU0FBUztJQUNULDJEQUEyRDtJQUMzRCxvREFBb0Q7SUFDcEQsNERBQTREO0lBQzVELDRDQUE0QztJQUM1QyxtREFBbUQ7SUFDbkQsdURBQXVEO0lBQ3ZEO1FBQUNiO0tBQUk7SUFDTCx3RUFBd0U7SUFDeEUsd0RBQXdEO0lBQ3hELHVEQUF1RDtJQUN2RCxJQUFJNkosY0FBYzVRLGtEQUFXQSxDQUM3QiwwRUFBMEU7SUFDMUUsMEVBQTBFO0lBQzFFLDBCQUEwQjtJQUMxQnlJLGVBQWVwRCxJQUFJLENBQUN6QyxXQUFXOEUsT0FBTztRQUFjLE9BQU8wSCxPQUFPMUIsT0FBTztJQUFFLElBQzNFLHVEQUF1RDtJQUN2RCxFQUFFO0lBQ0YseUNBQXlDO0lBQ3pDcEgsMEJBQTBCO1FBQ3RCK0ksV0FBVzNCLE9BQU8sR0FBR1U7UUFDckJrQixVQUFVNUIsT0FBTyxHQUFHakQ7SUFDeEI7SUFDQSxnQ0FBZ0M7SUFDaENuRSwwQkFBMEI7UUFDdEIsSUFBSSxDQUFDUyxLQUNEO1FBQ0osSUFBSThKLGFBQWE5SixRQUFRcUksT0FBTzFCLE9BQU87UUFDdkMsSUFBSW9ELGlCQUFpQmhKLFdBQVd6QyxJQUFJLENBQUN6QyxXQUFXNkw7UUFDaEQsMEVBQTBFO1FBQzFFLG1DQUFtQztRQUNuQyxJQUFJc0MsZ0JBQWdCLFNBQVVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxtQkFBbUI7WUFDeEU1RCxTQUFTckssYUFBYTtnQkFDbEIyRSxPQUFPcUo7Z0JBQ1BwSixjQUFjcUo7WUFDbEIsR0FDQSxnRUFBZ0U7WUFDaEUsbUJBQW1CO1lBQ25CbkYsUUFBUXFCLFNBQVNNLE9BQU8sQ0FBQy9GLElBQUksRUFBRXFKLGVBQ3pCcE8sWUFDQTtnQkFDRStFLE1BQU1xSjtZQUNWO1FBQ1I7UUFDQSxtRUFBbUU7UUFDbkUsaUNBQWlDO1FBQ2pDLElBQUlHLHlCQUF5QjtRQUM3QixJQUFJQyxlQUFlLFNBQVVwTixJQUFJO1lBQzdCLElBQUlBLFFBQVFzRCxhQUFhO2dCQUNyQixJQUFJK0osTUFBTWxOLEtBQUtrTixHQUFHO2dCQUNsQixJQUFJOUIsWUFBWS9ELGlCQUFpQixJQUM3QjZGLE1BQU1GLDBCQUNOM0IsWUFBWTtvQkFDWjJCLHlCQUF5QkUsTUFBTTlCLFlBQVkzRCxxQkFBcUI7b0JBQ2hFa0Y7Z0JBQ0o7WUFDSixPQUNLLElBQUk5TSxRQUFRdUQsaUJBQWlCO2dCQUM5QixJQUFJZ0ksWUFBWTlELHFCQUFxQixJQUFJK0QsWUFBWTtvQkFDakRzQjtnQkFDSjtZQUNKLE9BQ0ssSUFBSTlNLFFBQVF3RCxjQUFjO2dCQUMzQixPQUFPTTtZQUNYO1lBQ0E7UUFDSjtRQUNBLElBQUl3SixjQUFjakQsa0JBQWtCdEgsS0FBS21CLGdCQUFnQjZJO1FBQ3pELElBQUlRLGNBQWNsRCxrQkFBa0J0SCxLQUFLa0Isb0JBQW9CbUo7UUFDN0QsK0RBQStEO1FBQy9EbEUsYUFBYVEsT0FBTyxHQUFHO1FBQ3ZCMEIsT0FBTzFCLE9BQU8sR0FBRzNHO1FBQ2pCb0ksa0JBQWtCekIsT0FBTyxHQUFHO1FBQzVCLDJEQUEyRDtRQUMzRCx1Q0FBdUM7UUFDdkMsSUFBSW1ELFlBQVk7WUFDWnZELFNBQVM7Z0JBQ0wzRixNQUFNQTtnQkFDTkMsT0FBT0E7Z0JBQ1BDLGNBQWNBO1lBQ2xCO1FBQ0o7UUFDQSwwQkFBMEI7UUFDMUIsSUFBSWdJLG9CQUFvQjtZQUNwQixJQUFJOU0sWUFBWTRFLFNBQVN4QixXQUFXO2dCQUNoQywwQkFBMEI7Z0JBQzFCMks7WUFDSixPQUNLO2dCQUNELG1FQUFtRTtnQkFDbkUsYUFBYTtnQkFDYjFLLElBQUkwSztZQUNSO1FBQ0o7UUFDQSxPQUFPO1lBQ0gsd0JBQXdCO1lBQ3hCNUQsYUFBYVEsT0FBTyxHQUFHO1lBQ3ZCNEQ7WUFDQUM7UUFDSjtJQUNKLEdBQUc7UUFBQ3hLO1FBQUtlO0tBQVc7SUFDcEIsVUFBVTtJQUNWeEIsMEJBQTBCO1FBQ3RCLElBQUlrTDtRQUNKLFNBQVMxUTtZQUNMLDBCQUEwQjtZQUMxQixzRUFBc0U7WUFDdEUsSUFBSTJRLFdBQVd6TyxXQUFXK0wsbUJBQ3BCQSxnQkFBZ0JwSCxRQUNoQm9IO1lBQ04sa0VBQWtFO1lBQ2xFLG1EQUFtRDtZQUNuRCxnRUFBZ0U7WUFDaEUsSUFBSTBDLFlBQVlELFVBQVUsQ0FBQyxHQUFHO2dCQUMxQkEsUUFBUW5MLFdBQVdxTCxTQUFTRDtZQUNoQztRQUNKO1FBQ0EsU0FBU0M7WUFDTCwrQkFBK0I7WUFDL0Isb0VBQW9FO1lBQ3BFLElBQUksQ0FBQ3RFLFNBQVNNLE9BQU8sQ0FBQzlGLEtBQUssSUFDdEJvSCxDQUFBQSxxQkFBcUJPLFlBQVk3SixTQUFTLEVBQUMsS0FDM0N1SixDQUFBQSxzQkFBc0JNLFlBQVl2SyxRQUFRLEVBQUMsR0FBSTtnQkFDaEQ4QyxXQUFXMkcsYUFBYXROLElBQUksQ0FBQ0w7WUFDakMsT0FDSztnQkFDRCx5Q0FBeUM7Z0JBQ3pDQTtZQUNKO1FBQ0o7UUFDQUE7UUFDQSxPQUFPO1lBQ0gsSUFBSTBRLE9BQU87Z0JBQ1BHLGFBQWFIO2dCQUNiQSxRQUFRLENBQUM7WUFDYjtRQUNKO0lBQ0osR0FBRztRQUFDekM7UUFBaUJDO1FBQW1CQztRQUFvQm5IO0tBQVc7SUFDdkUsd0NBQXdDO0lBQ3hDN0gsb0RBQWFBLENBQUMwSDtJQUNkLDREQUE0RDtJQUM1RCw2RUFBNkU7SUFDN0UsMkVBQTJFO0lBQzNFLHlCQUF5QjtJQUN6QixJQUFJa0gsWUFBWTlMLFlBQVk0RSxTQUFTWixLQUFLO1FBQ3RDLHFFQUFxRTtRQUNyRXNJLFdBQVczQixPQUFPLEdBQUdVO1FBQ3JCa0IsVUFBVTVCLE9BQU8sR0FBR2pEO1FBQ3BCeUMsYUFBYVEsT0FBTyxHQUFHO1FBQ3ZCLE1BQU0zSyxZQUFZNkUsU0FBU0UsV0FBVzJHLGVBQWU3RztJQUN6RDtJQUNBLE9BQU87UUFDSHNDLFFBQVEwRztRQUNSLElBQUlqSixRQUFPO1lBQ1BvSSxrQkFBa0JwSSxJQUFJLEdBQUc7WUFDekIsT0FBT0E7UUFDWDtRQUNBLElBQUlDLFNBQVE7WUFDUm1JLGtCQUFrQm5JLEtBQUssR0FBRztZQUMxQixPQUFPQTtRQUNYO1FBQ0EsSUFBSUMsZ0JBQWU7WUFDZmtJLGtCQUFrQmxJLFlBQVksR0FBRztZQUNqQyxPQUFPQTtRQUNYO0lBQ0o7QUFDSjtBQUNBLElBQUkrSixZQUFZL08sT0FBT2dQLGNBQWMsQ0FBQ2xGLGFBQWEsV0FBVztJQUMxRG5NLE9BQU8ySztBQUNYO0FBQ0EsSUFBSTJHLHFCQUFxQixTQUFVL0ssR0FBRztJQUFJLE9BQU9ELFVBQVVDLElBQUksQ0FBQyxFQUFFO0FBQUU7QUFDcEUsSUFBSWdMLFNBQVNqRSxTQUFTYTtBQUV0QixTQUFTO0FBRXlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnJlZXplLW5leHQvLi9ub2RlX21vZHVsZXMvc3dyL2Rpc3QvaW5kZXgubWpzPzYyZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCBjcmVhdGVFbGVtZW50LCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VEZWJ1Z1ZhbHVlIH0gZnJvbSAncmVhY3QnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG4vLyBVc2luZyBub29wKCkgYXMgdGhlIHVuZGVmaW5lZCB2YWx1ZSBhcyB1bmRlZmluZWQgY2FuIHBvc3NpYmx5IGJlIHJlcGxhY2VkXG4vLyBieSBzb21ldGhpbmcgZWxzZS4gIFByZXR0aWVyIGlnbm9yZSBhbmQgZXh0cmEgcGFyZW50aGVzZXMgYXJlIG5lY2Vzc2FyeSBoZXJlXG4vLyB0byBlbnN1cmUgdGhhdCB0c2MgZG9lc24ndCByZW1vdmUgdGhlIF9fTk9JTkxJTkVfXyBjb21tZW50LlxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgVU5ERUZJTkVEID0gKCAvKiNfX05PSU5MSU5FX18qL25vb3AoKSk7XG52YXIgT0JKRUNUID0gT2JqZWN0O1xudmFyIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IFVOREVGSU5FRDsgfTtcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHR5cGVvZiB2ID09ICdmdW5jdGlvbic7IH07XG52YXIgbWVyZ2VPYmplY3RzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE9CSkVDVC5hc3NpZ24oe30sIGEsIGIpOyB9O1xudmFyIFNUUl9VTkRFRklORUQgPSAndW5kZWZpbmVkJztcbi8vIE5PVEU6IFVzZSBmdW5jdGlvbiB0byBndWFyYW50ZWUgaXQncyByZS1ldmFsdWF0ZWQgYmV0d2VlbiBqc2RvbSBhbmQgbm9kZSBydW50aW1lIGZvciB0ZXN0cy5cbnZhciBoYXNXaW5kb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2Ygd2luZG93ICE9IFNUUl9VTkRFRklORUQ7IH07XG52YXIgaGFzRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT0gU1RSX1VOREVGSU5FRDsgfTtcbnZhciBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhhc1dpbmRvdygpICYmIHR5cGVvZiB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddICE9IFNUUl9VTkRFRklORUQ7XG59O1xuXG4vLyB1c2UgV2Vha01hcCB0byBzdG9yZSB0aGUgb2JqZWN0LT5rZXkgbWFwcGluZ1xuLy8gc28gdGhlIG9iamVjdHMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuLy8gV2Vha01hcCB1c2VzIGEgaGFzaHRhYmxlIHVuZGVyIHRoZSBob29kLCBzbyB0aGUgbG9va3VwXG4vLyBjb21wbGV4aXR5IGlzIGFsbW9zdCBPKDEpLlxudmFyIHRhYmxlID0gbmV3IFdlYWtNYXAoKTtcbi8vIGNvdW50ZXIgb2YgdGhlIGtleVxudmFyIGNvdW50ZXIgPSAwO1xuLy8gQSBzdGFibGUgaGFzaCBpbXBsZW1lbnRhdGlvbiB0aGF0IHN1cHBvcnRzOlxuLy8gLSBGYXN0IGFuZCBlbnN1cmVzIHVuaXF1ZSBoYXNoIHByb3BlcnRpZXNcbi8vIC0gSGFuZGxlcyB1bnNlcmlhbGl6YWJsZSB2YWx1ZXNcbi8vIC0gSGFuZGxlcyBvYmplY3Qga2V5IG9yZGVyaW5nXG4vLyAtIEdlbmVyYXRlcyBzaG9ydCByZXN1bHRzXG4vL1xuLy8gVGhpcyBpcyBub3QgYSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZVxuLy8gcGFyc2libGUuXG52YXIgc3RhYmxlSGFzaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJnICYmIGFyZy5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgaXNEYXRlID0gY29uc3RydWN0b3IgPT0gRGF0ZTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBpbmRleDtcbiAgICBpZiAoT0JKRUNUKGFyZykgPT09IGFyZyAmJiAhaXNEYXRlICYmIGNvbnN0cnVjdG9yICE9IFJlZ0V4cCkge1xuICAgICAgICAvLyBPYmplY3QvZnVuY3Rpb24sIG5vdCBudWxsL2RhdGUvcmVnZXhwLiBVc2UgV2Vha01hcCB0byBzdG9yZSB0aGUgaWQgZmlyc3QuXG4gICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBoYXNoZWQsIGRpcmVjdGx5IHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICByZXN1bHQgPSB0YWJsZS5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBoYXNoIGZpcnN0IGZvciBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0aW9uIGJlZm9yZSBlbnRlcmluZyB0aGVcbiAgICAgICAgLy8gcmVjdXJzaXZlIGBzdGFibGVIYXNoYCBjYWxscy5cbiAgICAgICAgLy8gRm9yIG90aGVyIG9iamVjdHMgbGlrZSBzZXQgYW5kIG1hcCwgd2UgdXNlIHRoaXMgaWQgZGlyZWN0bHkgYXMgdGhlIGhhc2guXG4gICAgICAgIHJlc3VsdCA9ICsrY291bnRlciArICd+JztcbiAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IEFycmF5KSB7XG4gICAgICAgICAgICAvLyBBcnJheS5cbiAgICAgICAgICAgIHJlc3VsdCA9ICdAJztcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFyZy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IE9CSkVDVCkge1xuICAgICAgICAgICAgLy8gT2JqZWN0LCBzb3J0IGtleXMuXG4gICAgICAgICAgICByZXN1bHQgPSAnIyc7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9CSkVDVC5rZXlzKGFyZykuc29ydCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFpc1VuZGVmaW5lZCgoaW5kZXggPSBrZXlzLnBvcCgpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBpbmRleCArICc6JyArIHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaXNEYXRlXG4gICAgICAgICAgICA/IGFyZy50b0pTT04oKVxuICAgICAgICAgICAgOiB0eXBlID09ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgPyBhcmcudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogdHlwZSA9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGFyZylcbiAgICAgICAgICAgICAgICAgICAgOiAnJyArIGFyZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRHVlIHRvIGJ1ZyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NzgwNzUsXG4gKiBpdCdzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgaXMgY3VycmVudGx5IG9ubGluZSBvciBvZmZsaW5lXG4gKiBiYXNlZCBvbiBgbmF2aWdhdG9yLm9uTGluZWAuXG4gKiBBcyBhIHdvcmsgYXJvdW5kLCB3ZSBhbHdheXMgYXNzdW1lIGl0J3Mgb25saW5lIG9uIGZpcnN0IGxvYWQsIGFuZCBjaGFuZ2VcbiAqIHRoZSBzdGF0dXMgdXBvbiBgb25saW5lYCBvciBgb2ZmbGluZWAgZXZlbnRzLlxuICovXG52YXIgb25saW5lID0gdHJ1ZTtcbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ubGluZTsgfTtcbnZhciBoYXNXaW4gPSBoYXNXaW5kb3coKTtcbnZhciBoYXNEb2MgPSBoYXNEb2N1bWVudCgpO1xuLy8gRm9yIG5vZGUgYW5kIFJlYWN0IE5hdGl2ZSwgYGFkZC9yZW1vdmVFdmVudExpc3RlbmVyYCBkb2Vzbid0IGV4aXN0IG9uIHdpbmRvdy5cbnZhciBvbldpbmRvd0V2ZW50ID0gaGFzV2luICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgPyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbiAgICA6IG5vb3A7XG52YXIgb25Eb2N1bWVudEV2ZW50ID0gaGFzRG9jID8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKGRvY3VtZW50KSA6IG5vb3A7XG52YXIgb2ZmV2luZG93RXZlbnQgPSBoYXNXaW4gJiYgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICA/IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuICAgIDogbm9vcDtcbnZhciBvZmZEb2N1bWVudEV2ZW50ID0gaGFzRG9jXG4gICAgPyBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZG9jdW1lbnQpXG4gICAgOiBub29wO1xudmFyIGlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlzaWJpbGl0eVN0YXRlID0gaGFzRG9jICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmlzaWJpbGl0eVN0YXRlKSB8fCB2aXNpYmlsaXR5U3RhdGUgIT09ICdoaWRkZW4nO1xufTtcbnZhciBpbml0Rm9jdXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBmb2N1cyByZXZhbGlkYXRlXG4gICAgb25Eb2N1bWVudEV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgIG9uV2luZG93RXZlbnQoJ2ZvY3VzJywgY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZkRvY3VtZW50RXZlbnQoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcbnZhciBpbml0UmVjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gcmV2YWxpZGF0ZSBvbiByZWNvbm5lY3RlZFxuICAgIHZhciBvbk9ubGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25saW5lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIC8vIG5vdGhpbmcgdG8gcmV2YWxpZGF0ZSwganVzdCB1cGRhdGUgdGhlIHN0YXR1c1xuICAgIHZhciBvbk9mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ubGluZSA9IGZhbHNlO1xuICAgIH07XG4gICAgb25XaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgIG9uV2luZG93RXZlbnQoJ29mZmxpbmUnLCBvbk9mZmxpbmUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvbmxpbmUnLCBvbk9ubGluZSk7XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICB9O1xufTtcbnZhciBwcmVzZXQgPSB7XG4gICAgaXNPbmxpbmU6IGlzT25saW5lLFxuICAgIGlzVmlzaWJsZTogaXNWaXNpYmxlXG59O1xudmFyIGRlZmF1bHRDb25maWdPcHRpb25zID0ge1xuICAgIGluaXRGb2N1czogaW5pdEZvY3VzLFxuICAgIGluaXRSZWNvbm5lY3Q6IGluaXRSZWNvbm5lY3Rcbn07XG5cbnZhciBJU19TRVJWRVIgPSAhaGFzV2luZG93KCkgfHwgJ0Rlbm8nIGluIHdpbmRvdztcbi8vIFBvbHlmaWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZVxudmFyIHJBRiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSgpID8gd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXShmKSA6IHNldFRpbWVvdXQoZiwgMSk7XG59O1xuLy8gUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbi8vIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IElTX1NFUlZFUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbi8vIFRoaXMgYXNzaWdubWVudCBpcyB0byBleHRlbmQgdGhlIE5hdmlnYXRvciB0eXBlIHRvIHVzZSBlZmZlY3RpdmVUeXBlLlxudmFyIG5hdmlnYXRvckNvbm5lY3Rpb24gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG5hdmlnYXRvci5jb25uZWN0aW9uO1xuLy8gQWRqdXN0IHRoZSBjb25maWcgYmFzZWQgb24gc2xvdyBjb25uZWN0aW9uIHN0YXR1cyAoPD0gNzBLYnBzKS5cbnZhciBzbG93Q29ubmVjdGlvbiA9ICFJU19TRVJWRVIgJiZcbiAgICBuYXZpZ2F0b3JDb25uZWN0aW9uICYmXG4gICAgKFsnc2xvdy0yZycsICcyZyddLmluY2x1ZGVzKG5hdmlnYXRvckNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZSkgfHxcbiAgICAgICAgbmF2aWdhdG9yQ29ubmVjdGlvbi5zYXZlRGF0YSk7XG5cbnZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oa2V5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0ga2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIG5vdCByZWFkeVxuICAgICAgICAgICAga2V5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBbXS5jb25jYXQoa2V5KTtcbiAgICAvLyBJZiBrZXkgaXMgbm90IGZhbHN5LCBvciBub3QgYW4gZW1wdHkgYXJyYXksIGhhc2ggaXQuXG4gICAga2V5ID1cbiAgICAgICAgdHlwZW9mIGtleSA9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgIDogKEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleS5sZW5ndGggOiBrZXkpXG4gICAgICAgICAgICAgICAgPyBzdGFibGVIYXNoKGtleSlcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgIHZhciBpbmZvS2V5ID0ga2V5ID8gJyRzd3IkJyArIGtleSA6ICcnO1xuICAgIHJldHVybiBba2V5LCBhcmdzLCBpbmZvS2V5XTtcbn07XG5cbi8vIEdsb2JhbCBzdGF0ZSB1c2VkIHRvIGRlZHVwbGljYXRlIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnNcbnZhciBTV1JHbG9iYWxTdGF0ZSA9IG5ldyBXZWFrTWFwKCk7XG5cbnZhciBGT0NVU19FVkVOVCA9IDA7XG52YXIgUkVDT05ORUNUX0VWRU5UID0gMTtcbnZhciBNVVRBVEVfRVZFTlQgPSAyO1xuXG52YXIgYnJvYWRjYXN0U3RhdGUgPSBmdW5jdGlvbiAoY2FjaGUsIGtleSwgZGF0YSwgZXJyb3IsIGlzVmFsaWRhdGluZywgcmV2YWxpZGF0ZSwgYnJvYWRjYXN0KSB7XG4gICAgaWYgKGJyb2FkY2FzdCA9PT0gdm9pZCAwKSB7IGJyb2FkY2FzdCA9IHRydWU7IH1cbiAgICB2YXIgX2EgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpLCBFVkVOVF9SRVZBTElEQVRPUlMgPSBfYVswXSwgU1RBVEVfVVBEQVRFUlMgPSBfYVsxXSwgRkVUQ0ggPSBfYVszXTtcbiAgICB2YXIgcmV2YWxpZGF0b3JzID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV07XG4gICAgdmFyIHVwZGF0ZXJzID0gU1RBVEVfVVBEQVRFUlNba2V5XTtcbiAgICAvLyBDYWNoZSB3YXMgcG9wdWxhdGVkLCB1cGRhdGUgc3RhdGVzIG9mIGFsbCBob29rcy5cbiAgICBpZiAoYnJvYWRjYXN0ICYmIHVwZGF0ZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJzW2ldKGRhdGEsIGVycm9yLCBpc1ZhbGlkYXRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGFsc28gbmVlZCB0byByZXZhbGlkYXRlLCBvbmx5IGRvIGl0IGZvciB0aGUgZmlyc3QgaG9vay5cbiAgICBpZiAocmV2YWxpZGF0ZSkge1xuICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSBrZXkgYnkgZGVsZXRpbmcgdGhlIGNvbmN1cnJlbnQgcmVxdWVzdCBtYXJrZXJzIHNvIG5ld1xuICAgICAgICAvLyByZXF1ZXN0cyB3aWxsIG5vdCBiZSBkZWR1cGVkLlxuICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgaWYgKHJldmFsaWRhdG9ycyAmJiByZXZhbGlkYXRvcnNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0oTVVUQVRFX0VWRU5UKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG59O1xuXG4vLyBHbG9iYWwgdGltZXN0YW1wLlxudmFyIF9fdGltZXN0YW1wID0gMDtcbnZhciBnZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiArK19fdGltZXN0YW1wOyB9O1xuXG52YXIgaW50ZXJuYWxNdXRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FjaGUsIF9rZXksIF9kYXRhLCBfb3B0cywgb3B0aW9ucywgcG9wdWxhdGVDYWNoZSwgcmV2YWxpZGF0ZSwgcm9sbGJhY2tPbkVycm9yLCBjdXN0b21PcHRpbWlzdGljRGF0YSwgX2EsIGtleSwga2V5SW5mbywgX2IsIE1VVEFUSU9OLCBkYXRhLCBlcnJvciwgYmVmb3JlTXV0YXRpb25UcywgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEsIHJvbGxiYWNrRGF0YSwgb3B0aW1pc3RpY0RhdGEsIHJlcztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBhcmdzWzBdLCBfa2V5ID0gYXJnc1sxXSwgX2RhdGEgPSBhcmdzWzJdLCBfb3B0cyA9IGFyZ3NbM107XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2YgX29wdHMgPT09ICdib29sZWFuJyA/IHsgcmV2YWxpZGF0ZTogX29wdHMgfSA6IF9vcHRzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZUNhY2hlID0gaXNVbmRlZmluZWQob3B0aW9ucy5wb3B1bGF0ZUNhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMucG9wdWxhdGVDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSA9IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJvbGxiYWNrT25FcnJvciA9IG9wdGlvbnMucm9sbGJhY2tPbkVycm9yICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tT3B0aW1pc3RpY0RhdGEgPSBvcHRpb25zLm9wdGltaXN0aWNEYXRhO1xuICAgICAgICAgICAgICAgICAgICBfYSA9IHNlcmlhbGl6ZShfa2V5KSwga2V5ID0gX2FbMF0sIGtleUluZm8gPSBfYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIF9iID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKSwgTVVUQVRJT04gPSBfYlsyXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmV3IGRhdGEgcHJvdmlkZWQsIHJldmFsaWRhdGUgdGhlIGtleSB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgYW5kIGJyb2FkY2FzdCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBjYWNoZS5nZXQoa2V5KSwgVU5ERUZJTkVELCBVTkRFRklORUQsIHJldmFsaWRhdGUsIHRydWUpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2RhdGE7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZU11dGF0aW9uVHMgPSBnZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgICAgICAgICAgTVVUQVRJT05ba2V5XSA9IFtiZWZvcmVNdXRhdGlvblRzLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ3VzdG9tT3B0aW1pc3RpY0RhdGEgPSAhaXNVbmRlZmluZWQoY3VzdG9tT3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICByb2xsYmFja0RhdGEgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gb3B0aW1pc3RpYyBkYXRhIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWlzdGljRGF0YSA9IGlzRnVuY3Rpb24oY3VzdG9tT3B0aW1pc3RpY0RhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXN0b21PcHRpbWlzdGljRGF0YShyb2xsYmFja0RhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21PcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIG9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIG9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGRhdGFgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgcGFzc2luZyBjdXJyZW50IGNhY2hlIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YShjYWNoZS5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgdGhyb3dzIGFuIGVycm9yIHN5bmNocm9ub3VzbHksIHdlIHNob3VsZG4ndCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgJiYgaXNGdW5jdGlvbihkYXRhLnRoZW4pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRhdGEuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSByYWNlIHdlIGRvbid0IHVwZGF0ZSBjYWNoZSBvciBicm9hZGNhc3QgdGhlIGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBtdXRhdGlvbiBpcyBhc3luYywgd2UgbmVlZCB0byBjaGVjayB0aW1lc3RhbXBzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcmFjZSB3ZSBkb24ndCB1cGRhdGUgY2FjaGUgb3IgYnJvYWRjYXN0IHRoZSBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlTXV0YXRpb25UcyAhPT0gTVVUQVRJT05ba2V5XVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIGhhc0N1c3RvbU9wdGltaXN0aWNEYXRhICYmIHJvbGxiYWNrT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm9sbGJhY2suIEFsd2F5cyBwb3B1bGF0ZSB0aGUgY2FjaGUgaW4gdGhpcyBjYXNlIGJ1dCB3aXRob3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSByb2xsYmFja0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCByb2xsYmFja0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHNob3VsZCB3cml0ZSBiYWNrIHRoZSBjYWNoZSBhZnRlciByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wdWxhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgcmVzdWx0IGludG8gZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwb3B1bGF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcG9wdWxhdGVDYWNoZShkYXRhLCByb2xsYmFja0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBjYWNoZWQgZGF0YSBpZiB0aGVyZSdzIG5vIGVycm9yLiBEYXRhIGNhbiBiZSBgdW5kZWZpbmVkYCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSBvciByZXNldCB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5SW5mbywgbWVyZ2VPYmplY3RzKGNhY2hlLmdldChrZXlJbmZvKSwgeyBlcnJvcjogZXJyb3IgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lc3RhbXAgdG8gbWFyayB0aGUgbXV0YXRpb24gaGFzIGVuZGVkLlxuICAgICAgICAgICAgICAgICAgICBNVVRBVElPTltrZXldWzFdID0gZ2V0VGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIGRhdGEsIGVycm9yLCBVTkRFRklORUQsIHJldmFsaWRhdGUsICEhcG9wdWxhdGVDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGVycm9yIG9yIHJldHVybiBkYXRhXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXMgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGVycm9yIG9yIHJldHVybiBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcG9wdWxhdGVDYWNoZSA/IHJlcyA6IGRhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbnZhciByZXZhbGlkYXRlQWxsS2V5cyA9IGZ1bmN0aW9uIChyZXZhbGlkYXRvcnMsIHR5cGUpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcmV2YWxpZGF0b3JzKSB7XG4gICAgICAgIGlmIChyZXZhbGlkYXRvcnNba2V5XVswXSlcbiAgICAgICAgICAgIHJldmFsaWRhdG9yc1trZXldWzBdKHR5cGUpO1xuICAgIH1cbn07XG52YXIgaW5pdENhY2hlID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIGdsb2JhbCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBwcm92aWRlciB3aWxsIGJlIHVzZWQgdG8gZGVkdXBsaWNhdGVcbiAgICAvLyByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzLiBBcyB3ZWxsIGFzIGEgbXV0YXRlIGZ1bmN0aW9uIHRoYXQgYm91bmQgdG9cbiAgICAvLyB0aGUgY2FjaGUuXG4gICAgLy8gUHJvdmlkZXIncyBnbG9iYWwgc3RhdGUgbWlnaHQgYmUgYWxyZWFkeSBpbml0aWFsaXplZC4gTGV0J3MgdHJ5IHRvIGdldCB0aGVcbiAgICAvLyBnbG9iYWwgc3RhdGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlciBmaXJzdC5cbiAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBtZXJnZU9iamVjdHMoZGVmYXVsdENvbmZpZ09wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGdsb2JhbCBzdGF0ZSBib3VuZCB0byB0aGUgcHJvdmlkZXIsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCB0aGVcbiAgICAgICAgLy8gbmV3IG11dGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgdmFyIEVWRU5UX1JFVkFMSURBVE9SUyA9IHt9O1xuICAgICAgICB2YXIgbXV0YXRlID0gaW50ZXJuYWxNdXRhdGUuYmluZChVTkRFRklORUQsIHByb3ZpZGVyKTtcbiAgICAgICAgdmFyIHVubW91bnQgPSBub29wO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXRlIGlmIGl0J3MgbmV3LCBvciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gZXh0ZW5kZWQuXG4gICAgICAgIFNXUkdsb2JhbFN0YXRlLnNldChwcm92aWRlciwgW0VWRU5UX1JFVkFMSURBVE9SUywge30sIHt9LCB7fSwgbXV0YXRlXSk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgcHJvdmlkZXIsIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBpdCBhbmQgc2V0dXAgRE9NIGV2ZW50c1xuICAgICAgICAvLyBsaXN0ZW5lcnMgZm9yIGBmb2N1c2AgYW5kIGByZWNvbm5lY3RgIGFjdGlvbnMuXG4gICAgICAgIGlmICghSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGxpc3RlbmluZyB0byB0aGUgbmF0aXZlIGV2ZW50cyBmb3IgYXV0byByZXZhbGlkYXRpb25zLFxuICAgICAgICAgICAgLy8gd2UgaW50ZW50aW9uYWxseSBwdXQgYSBkZWxheSAoc2V0VGltZW91dCkgaGVyZSB0byBtYWtlIHN1cmUgdGhleSBhcmVcbiAgICAgICAgICAgIC8vIGZpcmVkIGFmdGVyIGltbWVkaWF0ZSBKYXZhU2NyaXB0IGV4ZWN1dGlvbnMsIHdoaWNoIGNhbiBwb3NzaWJseSBiZVxuICAgICAgICAgICAgLy8gUmVhY3QncyBzdGF0ZSB1cGRhdGVzLlxuICAgICAgICAgICAgLy8gVGhpcyBhdm9pZHMgc29tZSB1bm5lY2Vzc2FyeSByZXZhbGlkYXRpb25zIHN1Y2ggYXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL2lzc3Vlcy8xNjgwLlxuICAgICAgICAgICAgdmFyIHJlbGVhc2VGb2N1c18xID0gb3B0cy5pbml0Rm9jdXMoc2V0VGltZW91dC5iaW5kKFVOREVGSU5FRCwgcmV2YWxpZGF0ZUFsbEtleXMuYmluZChVTkRFRklORUQsIEVWRU5UX1JFVkFMSURBVE9SUywgRk9DVVNfRVZFTlQpKSk7XG4gICAgICAgICAgICB2YXIgcmVsZWFzZVJlY29ubmVjdF8xID0gb3B0cy5pbml0UmVjb25uZWN0KHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIFJFQ09OTkVDVF9FVkVOVCkpKTtcbiAgICAgICAgICAgIHVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUZvY3VzXzEgJiYgcmVsZWFzZUZvY3VzXzEoKTtcbiAgICAgICAgICAgICAgICByZWxlYXNlUmVjb25uZWN0XzEgJiYgcmVsZWFzZVJlY29ubmVjdF8xKCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1bi1tb3VudGluZywgd2UgbmVlZCB0byByZW1vdmUgdGhlIGNhY2hlIHByb3ZpZGVyIGZyb20gdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gc3RvcmFnZSB0b28gYmVjYXVzZSBpdCdzIGEgc2lkZS1lZmZlY3QuIE90aGVyd2lzZSB3aGVuIHJlLW1vdW50aW5nIHdlXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBub3QgcmUtcmVnaXN0ZXIgdGhvc2UgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAgIFNXUkdsb2JhbFN0YXRlLmRlbGV0ZShwcm92aWRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gaW5qZWN0IGFuIGV4dHJhIGxheWVyIG9uIHRvcCBvZiBgcHJvdmlkZXJgIGluIHRoZSBmdXR1cmUsXG4gICAgICAgIC8vIHN1Y2ggYXMga2V5IHNlcmlhbGl6YXRpb24sIGF1dG8gR0MsIGV0Yy5cbiAgICAgICAgLy8gRm9yIG5vdywgaXQncyBqdXN0IGEgYE1hcGAgaW50ZXJmYWNlIHdpdGhvdXQgYW55IG1vZGlmaWNhdGlvbnMuXG4gICAgICAgIHJldHVybiBbcHJvdmlkZXIsIG11dGF0ZSwgdW5tb3VudF07XG4gICAgfVxuICAgIHJldHVybiBbcHJvdmlkZXIsIFNXUkdsb2JhbFN0YXRlLmdldChwcm92aWRlcilbNF1dO1xufTtcblxuLy8gZXJyb3IgcmV0cnlcbnZhciBvbkVycm9yUmV0cnkgPSBmdW5jdGlvbiAoXywgX18sIGNvbmZpZywgcmV2YWxpZGF0ZSwgb3B0cykge1xuICAgIHZhciBtYXhSZXRyeUNvdW50ID0gY29uZmlnLmVycm9yUmV0cnlDb3VudDtcbiAgICB2YXIgY3VycmVudFJldHJ5Q291bnQgPSBvcHRzLnJldHJ5Q291bnQ7XG4gICAgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgIHZhciB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICpcbiAgICAgICAgKDEgPDwgKGN1cnJlbnRSZXRyeUNvdW50IDwgOCA/IGN1cnJlbnRSZXRyeUNvdW50IDogOCkpKSAqIGNvbmZpZy5lcnJvclJldHJ5SW50ZXJ2YWw7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChtYXhSZXRyeUNvdW50KSAmJiBjdXJyZW50UmV0cnlDb3VudCA+IG1heFJldHJ5Q291bnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KHJldmFsaWRhdGUsIHRpbWVvdXQsIG9wdHMpO1xufTtcbi8vIERlZmF1bHQgY2FjaGUgcHJvdmlkZXJcbnZhciBfYSA9IGluaXRDYWNoZShuZXcgTWFwKCkpLCBjYWNoZSA9IF9hWzBdLCBtdXRhdGUgPSBfYVsxXTtcbi8vIERlZmF1bHQgY29uZmlnXG52YXIgZGVmYXVsdENvbmZpZyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgLy8gZXZlbnRzXG4gICAgb25Mb2FkaW5nU2xvdzogbm9vcCxcbiAgICBvblN1Y2Nlc3M6IG5vb3AsXG4gICAgb25FcnJvcjogbm9vcCxcbiAgICBvbkVycm9yUmV0cnk6IG9uRXJyb3JSZXRyeSxcbiAgICBvbkRpc2NhcmRlZDogbm9vcCxcbiAgICAvLyBzd2l0Y2hlc1xuICAgIHJldmFsaWRhdGVPbkZvY3VzOiB0cnVlLFxuICAgIHJldmFsaWRhdGVPblJlY29ubmVjdDogdHJ1ZSxcbiAgICByZXZhbGlkYXRlSWZTdGFsZTogdHJ1ZSxcbiAgICBzaG91bGRSZXRyeU9uRXJyb3I6IHRydWUsXG4gICAgLy8gdGltZW91dHNcbiAgICBlcnJvclJldHJ5SW50ZXJ2YWw6IHNsb3dDb25uZWN0aW9uID8gMTAwMDAgOiA1MDAwLFxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDEwMDAsXG4gICAgZGVkdXBpbmdJbnRlcnZhbDogMiAqIDEwMDAsXG4gICAgbG9hZGluZ1RpbWVvdXQ6IHNsb3dDb25uZWN0aW9uID8gNTAwMCA6IDMwMDAsXG4gICAgLy8gcHJvdmlkZXJzXG4gICAgY29tcGFyZTogZnVuY3Rpb24gKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gICAgICAgIHJldHVybiBzdGFibGVIYXNoKGN1cnJlbnREYXRhKSA9PSBzdGFibGVIYXNoKG5ld0RhdGEpO1xuICAgIH0sXG4gICAgaXNQYXVzZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgIGNhY2hlOiBjYWNoZSxcbiAgICBtdXRhdGU6IG11dGF0ZSxcbiAgICBmYWxsYmFjazoge31cbn0sIFxuLy8gdXNlIHdlYiBwcmVzZXQgYnkgZGVmYXVsdFxucHJlc2V0KTtcblxudmFyIG1lcmdlQ29uZmlncyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gTmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBoZXJlLlxuICAgIHZhciB2ID0gbWVyZ2VPYmplY3RzKGEsIGIpO1xuICAgIC8vIElmIHR3byBjb25maWdzIGFyZSBwcm92aWRlZCwgbWVyZ2UgdGhlaXIgYHVzZWAgYW5kIGBmYWxsYmFja2Agb3B0aW9ucy5cbiAgICBpZiAoYikge1xuICAgICAgICB2YXIgdTEgPSBhLnVzZSwgZjEgPSBhLmZhbGxiYWNrO1xuICAgICAgICB2YXIgdTIgPSBiLnVzZSwgZjIgPSBiLmZhbGxiYWNrO1xuICAgICAgICBpZiAodTEgJiYgdTIpIHtcbiAgICAgICAgICAgIHYudXNlID0gdTEuY29uY2F0KHUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZjEgJiYgZjIpIHtcbiAgICAgICAgICAgIHYuZmFsbGJhY2sgPSBtZXJnZU9iamVjdHMoZjEsIGYyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbnZhciBTV1JDb25maWdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG52YXIgU1dSQ29uZmlnJDEgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICAvLyBFeHRlbmQgcGFyZW50IGNvbnRleHQgdmFsdWVzIGFuZCBtaWRkbGV3YXJlLlxuICAgIHZhciBleHRlbmRlZENvbmZpZyA9IG1lcmdlQ29uZmlncyh1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpLCB2YWx1ZSk7XG4gICAgLy8gU2hvdWxkIG5vdCB1c2UgdGhlIGluaGVyaXRlZCBwcm92aWRlci5cbiAgICB2YXIgcHJvdmlkZXIgPSB2YWx1ZSAmJiB2YWx1ZS5wcm92aWRlcjtcbiAgICAvLyBVc2UgYSBsYXp5IGluaXRpYWxpemVkIHN0YXRlIHRvIGNyZWF0ZSB0aGUgY2FjaGUgb24gZmlyc3QgYWNjZXNzLlxuICAgIHZhciBjYWNoZUNvbnRleHQgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm92aWRlclxuICAgICAgICAgICAgPyBpbml0Q2FjaGUocHJvdmlkZXIoZXh0ZW5kZWRDb25maWcuY2FjaGUgfHwgY2FjaGUpLCB2YWx1ZSlcbiAgICAgICAgICAgIDogVU5ERUZJTkVEO1xuICAgIH0pWzBdO1xuICAgIC8vIE92ZXJyaWRlIHRoZSBjYWNoZSBpZiBhIG5ldyBwcm92aWRlciBpcyBnaXZlbi5cbiAgICBpZiAoY2FjaGVDb250ZXh0KSB7XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLmNhY2hlID0gY2FjaGVDb250ZXh0WzBdO1xuICAgICAgICBleHRlbmRlZENvbmZpZy5tdXRhdGUgPSBjYWNoZUNvbnRleHRbMV07XG4gICAgfVxuICAgIC8vIFVuc3Vic2NyaWJlIGV2ZW50cy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChjYWNoZUNvbnRleHQgPyBjYWNoZUNvbnRleHRbMl0gOiBVTkRFRklORUQpOyB9LCBbXSk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoU1dSQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgbWVyZ2VPYmplY3RzKHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiBleHRlbmRlZENvbmZpZ1xuICAgIH0pKTtcbn07XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2Ygc3RhdGUgd2l0aCBkZXBlbmRlbmN5LXRyYWNraW5nLlxuICovXG52YXIgdXNlU3RhdGVXaXRoRGVwcyA9IGZ1bmN0aW9uIChzdGF0ZSwgdW5tb3VudGVkUmVmKSB7XG4gICAgdmFyIHJlcmVuZGVyID0gdXNlU3RhdGUoe30pWzFdO1xuICAgIHZhciBzdGF0ZVJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgLy8gSWYgYSBzdGF0ZSBwcm9wZXJ0eSAoZGF0YSwgZXJyb3Igb3IgaXNWYWxpZGF0aW5nKSBpcyBhY2Nlc3NlZCBieSB0aGUgcmVuZGVyXG4gICAgLy8gZnVuY3Rpb24sIHdlIG1hcmsgdGhlIHByb3BlcnR5IGFzIGEgZGVwZW5kZW5jeSBzbyBpZiBpdCBpcyB1cGRhdGVkIGFnYWluXG4gICAgLy8gaW4gdGhlIGZ1dHVyZSwgd2UgdHJpZ2dlciBhIHJlcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgYWxzbyBrbm93biBhcyBkZXBlbmRlbmN5LXRyYWNraW5nLlxuICAgIHZhciBzdGF0ZURlcGVuZGVuY2llc1JlZiA9IHVzZVJlZih7XG4gICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2VcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBUbyBjaGFuZ2Ugc3RhdGVSZWYsIHBhc3MgdGhlIHZhbHVlcyBleHBsaWNpdGx5IHRvIHNldFN0YXRlOlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBzZXRTdGF0ZSh7XG4gICAgICogICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgICogICBkYXRhOiBuZXdEYXRhIC8vIHNldCBkYXRhIHRvIG5ld0RhdGFcbiAgICAgKiAgIGVycm9yOiB1bmRlZmluZWQgLy8gc2V0IGVycm9yIHRvIHVuZGVmaW5lZFxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBzZXRTdGF0ZSh7XG4gICAgICogICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgICogICBkYXRhOiB1bmRlZmluZWQgLy8gc2V0IGRhdGEgdG8gdW5kZWZpbmVkXG4gICAgICogICBlcnJvcjogZXJyIC8vIHNldCBlcnJvciB0byBlcnJcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBzaG91bGRSZXJlbmRlciA9IGZhbHNlO1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgZm9yICh2YXIgXyBpbiBwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgayA9IF87XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaGFzIGNoYW5nZWQsIHVwZGF0ZSB0aGUgc3RhdGUgYW5kIG1hcmsgcmVyZW5kZXIgYXNcbiAgICAgICAgICAgIC8vIG5lZWRlZC5cbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGVba10gIT09IHBheWxvYWRba10pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGVba10gPSBwYXlsb2FkW2tdO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCBieSB0aGUgY29tcG9uZW50LCBhIHJlcmVuZGVyIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJlZC5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVEZXBlbmRlbmNpZXNSZWYuY3VycmVudFtrXSkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRSZXJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXJlbmRlciAmJiAhdW5tb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlcmVuZGVyKHt9KTtcbiAgICAgICAgfVxuICAgIH0sIFxuICAgIC8vIGNvbmZpZy5zdXNwZW5zZSBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXSk7XG4gICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgc3RhdGUgcmVmZXJlbmNlLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gc3RhdGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtzdGF0ZVJlZiwgc3RhdGVEZXBlbmRlbmNpZXNSZWYuY3VycmVudCwgc2V0U3RhdGVdO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oYXJnc1sxXSlcbiAgICAgICAgPyBbYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSB8fCB7fV1cbiAgICAgICAgOiBbYXJnc1swXSwgbnVsbCwgKGFyZ3NbMV0gPT09IG51bGwgPyBhcmdzWzJdIDogYXJnc1sxXSkgfHwge31dO1xufTtcblxudmFyIHVzZVNXUkNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWcsIHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCkpO1xufTtcblxuLy8gSXQncyB0cmlja3kgdG8gcGFzcyBnZW5lcmljIHR5cGVzIGFzIHBhcmFtZXRlcnMsIHNvIHdlIGp1c3QgZGlyZWN0bHkgb3ZlcnJpZGVcbi8vIHRoZSB0eXBlcyBoZXJlLlxudmFyIHdpdGhBcmdzID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlU1dSQXJncygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGRlZmF1bHQgYW5kIGluaGVyaXRlZCBjb25maWd1cmF0aW9uLlxuICAgICAgICB2YXIgZmFsbGJhY2tDb25maWcgPSB1c2VTV1JDb25maWcoKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIGFyZ3VtZW50cy5cbiAgICAgICAgdmFyIF9hID0gbm9ybWFsaXplKGFyZ3MpLCBrZXkgPSBfYVswXSwgZm4gPSBfYVsxXSwgX2NvbmZpZyA9IF9hWzJdO1xuICAgICAgICAvLyBNZXJnZSBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgdmFyIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhmYWxsYmFja0NvbmZpZywgX2NvbmZpZyk7XG4gICAgICAgIC8vIEFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgdmFyIG5leHQgPSBob29rO1xuICAgICAgICB2YXIgdXNlID0gY29uZmlnLnVzZTtcbiAgICAgICAgaWYgKHVzZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHVzZS5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHVzZVtpXShuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dChrZXksIGZuIHx8IGNvbmZpZy5mZXRjaGVyLCBjb25maWcpO1xuICAgIH07XG59O1xuXG4vLyBBZGQgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2Yga2V5ZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCByZXR1cm5cbi8vIHRoZSB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbnZhciBzdWJzY3JpYmVDYWxsYmFjayA9IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIga2V5ZWRSZXZhbGlkYXRvcnMgPSBjYWxsYmFja3Nba2V5XSB8fCAoY2FsbGJhY2tzW2tleV0gPSBbXSk7XG4gICAga2V5ZWRSZXZhbGlkYXRvcnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0ga2V5ZWRSZXZhbGlkYXRvcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBPKDEpOiBmYXN0ZXIgdGhhbiBzcGxpY2VcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzW2luZGV4XSA9IGtleWVkUmV2YWxpZGF0b3JzW2tleWVkUmV2YWxpZGF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIFdJVEhfREVEVVBFID0geyBkZWR1cGU6IHRydWUgfTtcbnZhciB1c2VTV1JIYW5kbGVyID0gZnVuY3Rpb24gKF9rZXksIGZldGNoZXIsIGNvbmZpZykge1xuICAgIHZhciBjYWNoZSA9IGNvbmZpZy5jYWNoZSwgY29tcGFyZSA9IGNvbmZpZy5jb21wYXJlLCBmYWxsYmFja0RhdGEgPSBjb25maWcuZmFsbGJhY2tEYXRhLCBzdXNwZW5zZSA9IGNvbmZpZy5zdXNwZW5zZSwgcmV2YWxpZGF0ZU9uTW91bnQgPSBjb25maWcucmV2YWxpZGF0ZU9uTW91bnQsIHJlZnJlc2hJbnRlcnZhbCA9IGNvbmZpZy5yZWZyZXNoSW50ZXJ2YWwsIHJlZnJlc2hXaGVuSGlkZGVuID0gY29uZmlnLnJlZnJlc2hXaGVuSGlkZGVuLCByZWZyZXNoV2hlbk9mZmxpbmUgPSBjb25maWcucmVmcmVzaFdoZW5PZmZsaW5lO1xuICAgIHZhciBfYSA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSksIEVWRU5UX1JFVkFMSURBVE9SUyA9IF9hWzBdLCBTVEFURV9VUERBVEVSUyA9IF9hWzFdLCBNVVRBVElPTiA9IF9hWzJdLCBGRVRDSCA9IF9hWzNdO1xuICAgIC8vIGBrZXlgIGlzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBTV1IgYGRhdGFgIHN0YXRlLCBga2V5SW5mb2AgaG9sZHMgZXh0cmFcbiAgICAvLyBzdGF0ZXMgc3VjaCBhcyBgZXJyb3JgIGFuZCBgaXNWYWxpZGF0aW5nYCBpbnNpZGUsXG4gICAgLy8gYWxsIG9mIHRoZW0gYXJlIGRlcml2ZWQgZnJvbSBgX2tleWAuXG4gICAgLy8gYGZuQXJnc2AgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBrZXksIHdoaWNoIHdpbGwgYmUgcGFzc2VkXG4gICAgLy8gdG8gdGhlIGZldGNoZXIuXG4gICAgdmFyIF9iID0gc2VyaWFsaXplKF9rZXkpLCBrZXkgPSBfYlswXSwgZm5BcmdzID0gX2JbMV0sIGtleUluZm8gPSBfYlsyXTtcbiAgICAvLyBJZiBpdCdzIHRoZSBpbml0aWFsIHJlbmRlciBvZiB0aGlzIGhvb2suXG4gICAgdmFyIGluaXRpYWxNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBJZiB0aGUgaG9vayBpcyB1bm1vdW50ZWQgYWxyZWFkeS4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gcHJldmVudCBzb21lIGVmZmVjdHNcbiAgICAvLyB0byBiZSBjYWxsZWQgYWZ0ZXIgdW5tb3VudGluZy5cbiAgICB2YXIgdW5tb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBSZWZzIHRvIGtlZXAgdGhlIGtleSBhbmQgY29uZmlnLlxuICAgIHZhciBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcbiAgICB2YXIgZmV0Y2hlclJlZiA9IHVzZVJlZihmZXRjaGVyKTtcbiAgICB2YXIgY29uZmlnUmVmID0gdXNlUmVmKGNvbmZpZyk7XG4gICAgdmFyIGdldENvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ1JlZi5jdXJyZW50OyB9O1xuICAgIHZhciBpc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldENvbmZpZygpLmlzVmlzaWJsZSgpICYmIGdldENvbmZpZygpLmlzT25saW5lKCk7IH07XG4gICAgdmFyIHBhdGNoRmV0Y2hJbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnNldChrZXlJbmZvLCBtZXJnZU9iamVjdHMoY2FjaGUuZ2V0KGtleUluZm8pLCBpbmZvKSk7XG4gICAgfTtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgdGhhdCBTV1Igc2hvdWxkIHJldHVybi5cbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgdmFyIGZhbGxiYWNrID0gaXNVbmRlZmluZWQoZmFsbGJhY2tEYXRhKVxuICAgICAgICA/IGNvbmZpZy5mYWxsYmFja1trZXldXG4gICAgICAgIDogZmFsbGJhY2tEYXRhO1xuICAgIHZhciBkYXRhID0gaXNVbmRlZmluZWQoY2FjaGVkKSA/IGZhbGxiYWNrIDogY2FjaGVkO1xuICAgIHZhciBpbmZvID0gY2FjaGUuZ2V0KGtleUluZm8pIHx8IHt9O1xuICAgIHZhciBlcnJvciA9IGluZm8uZXJyb3I7XG4gICAgdmFyIGlzSW5pdGlhbE1vdW50ID0gIWluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgLy8gLSBTdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSdzIHN0YWxlIGRhdGEgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAvLyAtIE5vdCBzdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSBpcyBubyBmYWxsYmFjayBkYXRhIGFuZCBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQuXG4gICAgLy8gLSBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQgYnV0IGBkYXRhYCBpcyBub3QgZGVmaW5lZC5cbiAgICB2YXIgc2hvdWxkUmV2YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQgJiYgIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSlcbiAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRlT25Nb3VudDtcbiAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxuICAgICAgICBpZiAoZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVW5kZXIgc3VzcGVuc2UgbW9kZSwgaXQgd2lsbCBhbHdheXMgZmV0Y2ggb24gcmVuZGVyIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIHN0YWxlIGRhdGEgc28gbm8gbmVlZCB0byByZXZhbGlkYXRlIGltbWVkaWF0ZWx5IG9uIG1vdW50IGFnYWluLlxuICAgICAgICAvLyBJZiBkYXRhIGV4aXN0cywgb25seSByZXZhbGlkYXRlIGlmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHN1c3BlbnNlKVxuICAgICAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpID8gZmFsc2UgOiBjb25maWcucmV2YWxpZGF0ZUlmU3RhbGU7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHN0YWxlIGRhdGEsIHdlIG5lZWQgdG8gcmV2YWxpZGF0ZSBvbiBtb3VudDtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbCBhbHdheXMgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpIHx8IGNvbmZpZy5yZXZhbGlkYXRlSWZTdGFsZTtcbiAgICB9O1xuICAgIC8vIFJlc29sdmUgdGhlIGN1cnJlbnQgdmFsaWRhdGluZyBzdGF0ZS5cbiAgICB2YXIgcmVzb2x2ZVZhbGlkYXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2V5IHx8ICFmZXRjaGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5pc1ZhbGlkYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gSWYgaXQncyBub3QgbW91bnRlZCB5ZXQgYW5kIGl0IHNob3VsZCByZXZhbGlkYXRlIG9uIG1vdW50LCByZXZhbGlkYXRlLlxuICAgICAgICByZXR1cm4gaXNJbml0aWFsTW91bnQgJiYgc2hvdWxkUmV2YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgdmFyIGlzVmFsaWRhdGluZyA9IHJlc29sdmVWYWxpZGF0aW5nKCk7XG4gICAgdmFyIF9jID0gdXNlU3RhdGVXaXRoRGVwcyh7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBpc1ZhbGlkYXRpbmdcbiAgICB9LCB1bm1vdW50ZWRSZWYpLCBzdGF0ZVJlZiA9IF9jWzBdLCBzdGF0ZURlcGVuZGVuY2llcyA9IF9jWzFdLCBzZXRTdGF0ZSA9IF9jWzJdO1xuICAgIC8vIFRoZSByZXZhbGlkYXRpb24gZnVuY3Rpb24gaXMgYSBjYXJlZnVsbHkgY3JhZnRlZCB3cmFwcGVyIG9mIHRoZSBvcmlnaW5hbFxuICAgIC8vIGBmZXRjaGVyYCwgdG8gY29ycmVjdGx5IGhhbmRsZSB0aGUgbWFueSBlZGdlIGNhc2VzLlxuICAgIHZhciByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJldmFsaWRhdGVPcHRzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudEZldGNoZXIsIG5ld0RhdGEsIHN0YXJ0QXQsIGxvYWRpbmcsIG9wdHMsIHNob3VsZFN0YXJ0TmV3UmVxdWVzdCwgaXNDdXJyZW50S2V5TW91bnRlZCwgY2xlYW51cFN0YXRlLCBuZXdTdGF0ZSwgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlLCBtdXRhdGlvbkluZm8sIGVycl8xO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGZXRjaGVyID0gZmV0Y2hlclJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWN1cnJlbnRGZXRjaGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHJldmFsaWRhdGVPcHRzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdGFydE5ld1JlcXVlc3QgPSAhRkVUQ0hba2V5XSB8fCAhb3B0cy5kZWR1cGU7XG4gICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudEtleU1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXVubW91bnRlZFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID09PSBrZXlSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3Mgc3RpbGwgdGhlIHNhbWUgcmVxdWVzdCBiZWZvcmUgZGVsZXRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdEluZm8gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RJbmZvICYmIHJlcXVlc3RJbmZvWzFdID09PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0geyBpc1ZhbGlkYXRpbmc6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHsgaXNWYWxpZGF0aW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IHNldCBzdGF0ZSBpZiBpdCdzIHNhZmUgKHN0aWxsIG1vdW50ZWQgd2l0aCB0aGUgc2FtZSBrZXkpLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZmV0Y2hpbmcuIENoYW5nZSB0aGUgYGlzVmFsaWRhdGluZ2Agc3RhdGUsIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmV0Y2hJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUoeyBpc1ZhbGlkYXRpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgYWxsIG90aGVyIGhvb2tzIHRvIGNoYW5nZSB0aGUgYGlzVmFsaWRhdGluZ2Agc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RTdGF0ZShjYWNoZSwga2V5LCBzdGF0ZVJlZi5jdXJyZW50LmRhdGEsIHN0YXRlUmVmLmN1cnJlbnQuZXJyb3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gY2FjaGUgYmVpbmcgcmVuZGVyZWQgY3VycmVudGx5IChpdCBzaG93cyBhIGJsYW5rIHBhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgbG9hZGluZyBzbG93IGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkaW5nVGltZW91dCAmJiAhY2FjaGUuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRpbmcgJiYgaXNDdXJyZW50S2V5TW91bnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkxvYWRpbmdTbG93KGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5sb2FkaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgcmVxdWVzdCBhbmQgc2F2ZSB0aGUgdGltZXN0YW1wLlxuICAgICAgICAgICAgICAgICAgICAgICAgRkVUQ0hba2V5XSA9IFtjdXJyZW50RmV0Y2hlci5hcHBseSh2b2lkIDAsIGZuQXJncyksIGdldFRpbWVzdGFtcCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYSA9IEZFVENIW2tleV0sIG5ld0RhdGEgPSBfYVswXSwgc3RhcnRBdCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXdEYXRhXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzbid0IGludGVycnVwdGVkLCBjbGVhbiBpdCB1cCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZHVwbGljYXRpb24gaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNsZWFudXBTdGF0ZSwgY29uZmlnLmRlZHVwaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3JlIG90aGVyIG9uZ29pbmcgcmVxdWVzdChzKSwgc3RhcnRlZCBhZnRlciB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaWdub3JlIHRoZSBjdXJyZW50IG9uZSB0byBhdm9pZCBwb3NzaWJsZSByYWNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgcmVxMS0tLS0tLS0tLS0tLS0tLS0tLT5yZXMxICAgICAgICAoY3VycmVudCBvbmUpXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICByZXEyLS0tLS0tLS0tLS0tLS0tLT5yZXMyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IHRoYXQgZmlyZWQgbGF0ZXIgd2lsbCBhbHdheXMgYmUga2VwdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRpbWVzdGFtcCBtYXliZSBiZSBgdW5kZWZpbmVkYCBvciBhIG51bWJlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUZFVENIW2tleV0gfHwgRkVUQ0hba2V5XVsxXSAhPT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZldGNoSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZS5lcnJvciA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JbmZvID0gTVVUQVRJT05ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChtdXRhdGlvbkluZm8pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGFydEF0IDw9IG11dGF0aW9uSW5mb1swXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QXQgPD0gbXV0YXRpb25JbmZvWzFdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25JbmZvWzFdID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIHdpdGggbGF0ZXN0IHN0YXRlIHRvIGF2b2lkIGV4dHJhIHJlLXJlbmRlcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBsb2NhbCBzdGF0ZSwgY29tcGFyZSBhbmQgYXNzaWduLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUoc3RhdGVSZWYuY3VycmVudC5kYXRhLCBuZXdEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGFuZCBuZXdEYXRhIGFyZSBkZWVwbHkgZXF1YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBzYWZlIHRvIGJyb2FkY2FzdCB0aGUgc3RhbGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUuZGF0YSA9IHN0YXRlUmVmLmN1cnJlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBlbmQgb2YgdGhpcyBmdW5jdGlvbiwgYGJyb2Nhc3RTdGF0ZWAgaW52b2tlcyB0aGUgYG9uU3RhdGVVcGRhdGVgIGZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggdGFrZXMgY2FyZSBvZiBhdm9pZGluZyB0aGUgcmUtcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGdsb2JhbCBzdGF0ZSwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBrZXkgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL3B1bGwvMTA1OFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUoY2FjaGUuZ2V0KGtleSksIG5ld0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzdWNjZXNzZnVsIGNhbGxiYWNrIGlmIGl0J3MgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vblN1Y2Nlc3MobmV3RGF0YSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgZXJyXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcGF1c2VkLCB3ZSBjb250aW51ZSBoYW5kbGluZyB0aGUgZXJyb3IuIE90aGVyd2lzZSBkaXNjYXJkIGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIG5ldyBlcnJvciwgZG9uJ3QgdXNlIGRlZXAgY29tcGFyaXNvbiBmb3IgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGZXRjaEluZm8oeyBlcnJvcjogZXJyXzEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZS5lcnJvciA9IGVycl8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3IgZXZlbnQgYW5kIHJldHJ5IGxvZ2ljLiBPbmx5IGZvciB0aGUgYWN0dWFsIHJlcXVlc3QsIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVkdXBlZCBvbmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCAmJiBpc0N1cnJlbnRLZXlNb3VudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkVycm9yKGVycl8xLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgY29uZmlnLnNob3VsZFJldHJ5T25FcnJvciA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGNvbmZpZy5zaG91bGRSZXRyeU9uRXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2hvdWxkUmV0cnlPbkVycm9yKGVycl8xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiByZXRyeWluZywgZGVkdXBlIGlzIGFsd2F5cyBlbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGFjdGl2ZSwgc3RvcC4gSXQgd2lsbCBhdXRvIHJldmFsaWRhdGUgd2hlbiByZWZvY3VzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciByZWNvbm5lY3RpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkVycm9yUmV0cnkoZXJyXzEsIGtleSwgY29uZmlnLCByZXZhbGlkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudDogKG9wdHMucmV0cnlDb3VudCB8fCAwKSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdXBlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgbG9hZGluZyBhcyBzdG9wcGVkLlxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBob29rJ3Mgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIHJlcXVlc3QsIG5lZWQgdG8gdGVsbCBhbGwgb3RoZXIgaG9va3MgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZWlyIHN0YXRlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudEtleU1vdW50ZWQoKSAmJiBzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdFN0YXRlKGNhY2hlLCBrZXksIG5ld1N0YXRlLmRhdGEsIG5ld1N0YXRlLmVycm9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTsgfSwgXG4gICAgLy8gYHNldFN0YXRlYCBpcyBpbW11dGFibGUsIGFuZCBgZXZlbnRzQ2FsbGJhY2tgLCBgZm5BcmdzYCwgYGtleUluZm9gLFxuICAgIC8vIGFuZCBga2V5VmFsaWRhdGluZ2AgYXJlIGRlcGVuZGluZyBvbiBga2V5YCwgc28gd2UgY2FuIGV4Y2x1ZGUgdGhlbSBmcm9tXG4gICAgLy8gdGhlIGRlcHMgYXJyYXkuXG4gICAgLy9cbiAgICAvLyBGSVhNRTpcbiAgICAvLyBgZm5gIGFuZCBgY29uZmlnYCBtaWdodCBiZSBjaGFuZ2VkIGR1cmluZyB0aGUgbGlmZWN5Y2xlLFxuICAgIC8vIGJ1dCB0aGV5IG1pZ2h0IGJlIGNoYW5nZWQgZXZlcnkgcmVuZGVyIGxpa2UgdGhpcy5cbiAgICAvLyBgdXNlU1dSKCdrZXknLCAoKSA9PiBmZXRjaCgnL2FwaS8nKSwgeyBzdXNwZW5zZTogdHJ1ZSB9KWBcbiAgICAvLyBTbyB3ZSBvbWl0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgZGVwcyBhcnJheVxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0IG1pZ2h0IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBba2V5XSk7XG4gICAgLy8gU2ltaWxhciB0byB0aGUgZ2xvYmFsIG11dGF0ZSwgYnV0IGJvdW5kIHRvIHRoZSBjdXJyZW50IGNhY2hlIGFuZCBrZXkuXG4gICAgLy8gYGNhY2hlYCBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgdmFyIGJvdW5kTXV0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgLy8gQnkgdXNpbmcgYGJpbmRgIHdlIGRvbid0IG5lZWQgdG8gbW9kaWZ5IHRoZSBzaXplIG9mIHRoZSByZXN0IGFyZ3VtZW50cy5cbiAgICAvLyBEdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzE4MSwgd2UgaGF2ZSB0b1xuICAgIC8vIGNhc3QgaXQgdG8gYW55IGZvciBub3cuXG4gICAgaW50ZXJuYWxNdXRhdGUuYmluZChVTkRFRklORUQsIGNhY2hlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlSZWYuY3VycmVudDsgfSksIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXSk7XG4gICAgLy8gQWx3YXlzIHVwZGF0ZSBmZXRjaGVyIGFuZCBjb25maWcgcmVmcy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgfSk7XG4gICAgLy8gQWZ0ZXIgbW91bnRlZCBvciBrZXkgY2hhbmdlZC5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBrZXlDaGFuZ2VkID0ga2V5ICE9PSBrZXlSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHNvZnRSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZS5iaW5kKFVOREVGSU5FRCwgV0lUSF9ERURVUEUpO1xuICAgICAgICAvLyBFeHBvc2Ugc3RhdGUgdXBkYXRlciB0byBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzLiBTbyB3ZSBjYW4gdXBkYXRlIGhvb2snc1xuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZSBmcm9tIHRoZSBvdXRzaWRlLlxuICAgICAgICB2YXIgb25TdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGVkRGF0YSwgdXBkYXRlZEVycm9yLCB1cGRhdGVkSXNWYWxpZGF0aW5nKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShtZXJnZU9iamVjdHMoe1xuICAgICAgICAgICAgICAgIGVycm9yOiB1cGRhdGVkRXJyb3IsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB1cGRhdGVkSXNWYWxpZGF0aW5nXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIFNpbmNlIGBzZXRTdGF0ZWAgb25seSBzaGFsbG93bHkgY29tcGFyZXMgc3RhdGVzLCB3ZSBkbyBhIGRlZXBcbiAgICAgICAgICAgIC8vIGNvbXBhcmlzb24gaGVyZS5cbiAgICAgICAgICAgIGNvbXBhcmUoc3RhdGVSZWYuY3VycmVudC5kYXRhLCB1cGRhdGVkRGF0YSlcbiAgICAgICAgICAgICAgICA/IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB1cGRhdGVkRGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhwb3NlIHJldmFsaWRhdG9ycyB0byBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzLiBTbyB3ZSBjYW4gdHJpZ2dlclxuICAgICAgICAvLyByZXZhbGlkYXRpb24gZnJvbSB0aGUgb3V0c2lkZS5cbiAgICAgICAgdmFyIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSAwO1xuICAgICAgICB2YXIgb25SZXZhbGlkYXRlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IEZPQ1VTX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPbkZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIG5vdyA+IG5leHRGb2N1c1JldmFsaWRhdGVkQXQgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gbm93ICsgZ2V0Q29uZmlnKCkuZm9jdXNUaHJvdHRsZUludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gUkVDT05ORUNUX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBNVVRBVEVfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5zdWJVcGRhdGUgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIFNUQVRFX1VQREFURVJTLCBvblN0YXRlVXBkYXRlKTtcbiAgICAgICAgdmFyIHVuc3ViRXZlbnRzID0gc3Vic2NyaWJlQ2FsbGJhY2soa2V5LCBFVkVOVF9SRVZBTElEQVRPUlMsIG9uUmV2YWxpZGF0ZSk7XG4gICAgICAgIC8vIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBtb3VudGVkIGFuZCB1cGRhdGUgY29ycmVzcG9uZGluZyByZWZzLlxuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBrZXlSZWYuY3VycmVudCA9IGtleTtcbiAgICAgICAgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIC8vIFdoZW4gYGtleWAgdXBkYXRlcywgcmVzZXQgdGhlIHN0YXRlIHRvIHRoZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIC8vIGFuZCB0cmlnZ2VyIGEgcmVyZW5kZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoa2V5Q2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogaXNWYWxpZGF0aW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uLlxuICAgICAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSgpKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGF0YSkgfHwgSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBzb2Z0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJldmFsaWRhdGUgaWYgd2UgaGF2ZSBkYXRhIHRvIHJldHVybiBzbyB3ZSB3b24ndCBibG9ja1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICByQUYoc29mdFJldmFsaWRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBNYXJrIGl0IGFzIHVubW91bnRlZC5cbiAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVuc3ViVXBkYXRlKCk7XG4gICAgICAgICAgICB1bnN1YkV2ZW50cygpO1xuICAgICAgICB9O1xuICAgIH0sIFtrZXksIHJldmFsaWRhdGVdKTtcbiAgICAvLyBQb2xsaW5nXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lcjtcbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcGFzc2VkIGludGVydmFsXG4gICAgICAgICAgICAvLyAuLi5vciBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHVwZGF0ZWQgZGF0YSB0byBnZXQgdGhlIGludGVydmFsXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBpc0Z1bmN0aW9uKHJlZnJlc2hJbnRlcnZhbClcbiAgICAgICAgICAgICAgICA/IHJlZnJlc2hJbnRlcnZhbChkYXRhKVxuICAgICAgICAgICAgICAgIDogcmVmcmVzaEludGVydmFsO1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzdGFydCBuZXh0IGludGVydmFsIGlmIGByZWZyZXNoSW50ZXJ2YWxgIGlzIG5vdCAwLCBhbmQ6XG4gICAgICAgICAgICAvLyAtIGBmb3JjZWAgaXMgdHJ1ZSwgd2hpY2ggaXMgdGhlIHN0YXJ0IG9mIHBvbGxpbmdcbiAgICAgICAgICAgIC8vIC0gb3IgYHRpbWVyYCBpcyBub3QgMCwgd2hpY2ggbWVhbnMgdGhlIGVmZmVjdCB3YXNuJ3QgY2FuY2VsZWRcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCAmJiB0aW1lciAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlY3V0ZSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIE9LIHRvIGV4ZWN1dGU6XG4gICAgICAgICAgICAvLyBPbmx5IHJldmFsaWRhdGUgd2hlbiB0aGUgcGFnZSBpcyB2aXNpYmxlLCBvbmxpbmUgYW5kIG5vdCBlcnJvcmVkLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZVJlZi5jdXJyZW50LmVycm9yICYmXG4gICAgICAgICAgICAgICAgKHJlZnJlc2hXaGVuSGlkZGVuIHx8IGdldENvbmZpZygpLmlzVmlzaWJsZSgpKSAmJlxuICAgICAgICAgICAgICAgIChyZWZyZXNoV2hlbk9mZmxpbmUgfHwgZ2V0Q29uZmlnKCkuaXNPbmxpbmUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlKFdJVEhfREVEVVBFKS50aGVuKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV4dCBpbnRlcnZhbCB0byBjaGVjayBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtyZWZyZXNoSW50ZXJ2YWwsIHJlZnJlc2hXaGVuSGlkZGVuLCByZWZyZXNoV2hlbk9mZmxpbmUsIHJldmFsaWRhdGVdKTtcbiAgICAvLyBEaXNwbGF5IGRlYnVnIGluZm8gaW4gUmVhY3QgRGV2VG9vbHMuXG4gICAgdXNlRGVidWdWYWx1ZShkYXRhKTtcbiAgICAvLyBJbiBTdXNwZW5zZSBtb2RlLCB3ZSBjYW4ndCByZXR1cm4gdGhlIGVtcHR5IGBkYXRhYCBzdGF0ZS5cbiAgICAvLyBJZiB0aGVyZSBpcyBgZXJyb3JgLCB0aGUgYGVycm9yYCBuZWVkcyB0byBiZSB0aHJvd24gdG8gdGhlIGVycm9yIGJvdW5kYXJ5LlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGBlcnJvcmAsIHRoZSBgcmV2YWxpZGF0aW9uYCBwcm9taXNlIG5lZWRzIHRvIGJlIHRocm93biB0b1xuICAgIC8vIHRoZSBzdXNwZW5zZSBib3VuZGFyeS5cbiAgICBpZiAoc3VzcGVuc2UgJiYgaXNVbmRlZmluZWQoZGF0YSkgJiYga2V5KSB7XG4gICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgZmV0Y2hlciBhbmQgY29uZmlnIHJlZnMgZXZlbiB3aXRoIHRoZSBTdXNwZW5zZSBtb2RlLlxuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgaXNVbmRlZmluZWQoZXJyb3IpID8gcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkgOiBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbXV0YXRlOiBib3VuZE11dGF0ZSxcbiAgICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5kYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc1ZhbGlkYXRpbmcoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5pc1ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRhdGluZztcbiAgICAgICAgfVxuICAgIH07XG59O1xudmFyIFNXUkNvbmZpZyA9IE9CSkVDVC5kZWZpbmVQcm9wZXJ0eShTV1JDb25maWckMSwgJ2RlZmF1bHQnLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRDb25maWdcbn0pO1xudmFyIHVuc3RhYmxlX3NlcmlhbGl6ZSA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHNlcmlhbGl6ZShrZXkpWzBdOyB9O1xudmFyIHVzZVNXUiA9IHdpdGhBcmdzKHVzZVNXUkhhbmRsZXIpO1xuXG4vLyB1c2VTV1JcblxuZXhwb3J0IHsgU1dSQ29uZmlnLCB1c2VTV1IgYXMgZGVmYXVsdCwgbXV0YXRlLCB1bnN0YWJsZV9zZXJpYWxpemUsIHVzZVNXUkNvbmZpZyB9O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VEZWJ1Z1ZhbHVlIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJvcCIsIlR5cGVFcnJvciIsImNhbGwiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwibm9vcCIsIlVOREVGSU5FRCIsIk9CSkVDVCIsIk9iamVjdCIsImlzVW5kZWZpbmVkIiwiaXNGdW5jdGlvbiIsIm1lcmdlT2JqZWN0cyIsImEiLCJiIiwiYXNzaWduIiwiU1RSX1VOREVGSU5FRCIsImhhc1dpbmRvdyIsImhhc0RvY3VtZW50IiwiZG9jdW1lbnQiLCJoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3aW5kb3ciLCJ0YWJsZSIsIldlYWtNYXAiLCJjb3VudGVyIiwic3RhYmxlSGFzaCIsImFyZyIsInR5cGUiLCJjb25zdHJ1Y3RvciIsImlzRGF0ZSIsIkRhdGUiLCJpbmRleCIsIlJlZ0V4cCIsImdldCIsInNldCIsIkFycmF5Iiwia2V5cyIsInNvcnQiLCJ0b0pTT04iLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJvbmxpbmUiLCJpc09ubGluZSIsImhhc1dpbiIsImhhc0RvYyIsIm9uV2luZG93RXZlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiYmluZCIsIm9uRG9jdW1lbnRFdmVudCIsIm9mZldpbmRvd0V2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZkRvY3VtZW50RXZlbnQiLCJpc1Zpc2libGUiLCJ2aXNpYmlsaXR5U3RhdGUiLCJpbml0Rm9jdXMiLCJjYWxsYmFjayIsImluaXRSZWNvbm5lY3QiLCJvbk9ubGluZSIsIm9uT2ZmbGluZSIsInByZXNldCIsImRlZmF1bHRDb25maWdPcHRpb25zIiwiSVNfU0VSVkVSIiwickFGIiwic2V0VGltZW91dCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJuYXZpZ2F0b3JDb25uZWN0aW9uIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNsb3dDb25uZWN0aW9uIiwiaW5jbHVkZXMiLCJlZmZlY3RpdmVUeXBlIiwic2F2ZURhdGEiLCJzZXJpYWxpemUiLCJrZXkiLCJlcnIiLCJhcmdzIiwiY29uY2F0IiwiaXNBcnJheSIsImluZm9LZXkiLCJTV1JHbG9iYWxTdGF0ZSIsIkZPQ1VTX0VWRU5UIiwiUkVDT05ORUNUX0VWRU5UIiwiTVVUQVRFX0VWRU5UIiwiYnJvYWRjYXN0U3RhdGUiLCJjYWNoZSIsImRhdGEiLCJlcnJvciIsImlzVmFsaWRhdGluZyIsInJldmFsaWRhdGUiLCJicm9hZGNhc3QiLCJfYSIsIkVWRU5UX1JFVkFMSURBVE9SUyIsIlNUQVRFX1VQREFURVJTIiwiRkVUQ0giLCJyZXZhbGlkYXRvcnMiLCJ1cGRhdGVycyIsImkiLCJfX3RpbWVzdGFtcCIsImdldFRpbWVzdGFtcCIsImludGVybmFsTXV0YXRlIiwiX2kiLCJhcmd1bWVudHMiLCJfa2V5IiwiX2RhdGEiLCJfb3B0cyIsIm9wdGlvbnMiLCJwb3B1bGF0ZUNhY2hlIiwicm9sbGJhY2tPbkVycm9yIiwiY3VzdG9tT3B0aW1pc3RpY0RhdGEiLCJrZXlJbmZvIiwiX2IiLCJNVVRBVElPTiIsImJlZm9yZU11dGF0aW9uVHMiLCJoYXNDdXN0b21PcHRpbWlzdGljRGF0YSIsInJvbGxiYWNrRGF0YSIsIm9wdGltaXN0aWNEYXRhIiwicmVzIiwiX2MiLCJjYXRjaCIsInJldmFsaWRhdGVBbGxLZXlzIiwiaW5pdENhY2hlIiwicHJvdmlkZXIiLCJoYXMiLCJvcHRzIiwibXV0YXRlIiwidW5tb3VudCIsInJlbGVhc2VGb2N1c18xIiwicmVsZWFzZVJlY29ubmVjdF8xIiwiZGVsZXRlIiwib25FcnJvclJldHJ5IiwiX18iLCJjb25maWciLCJtYXhSZXRyeUNvdW50IiwiZXJyb3JSZXRyeUNvdW50IiwiY3VycmVudFJldHJ5Q291bnQiLCJyZXRyeUNvdW50IiwidGltZW91dCIsIk1hdGgiLCJyYW5kb20iLCJlcnJvclJldHJ5SW50ZXJ2YWwiLCJNYXAiLCJkZWZhdWx0Q29uZmlnIiwib25Mb2FkaW5nU2xvdyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJvbkRpc2NhcmRlZCIsInJldmFsaWRhdGVPbkZvY3VzIiwicmV2YWxpZGF0ZU9uUmVjb25uZWN0IiwicmV2YWxpZGF0ZUlmU3RhbGUiLCJzaG91bGRSZXRyeU9uRXJyb3IiLCJmb2N1c1Rocm90dGxlSW50ZXJ2YWwiLCJkZWR1cGluZ0ludGVydmFsIiwibG9hZGluZ1RpbWVvdXQiLCJjb21wYXJlIiwiY3VycmVudERhdGEiLCJuZXdEYXRhIiwiaXNQYXVzZWQiLCJmYWxsYmFjayIsIm1lcmdlQ29uZmlncyIsInUxIiwidXNlIiwiZjEiLCJ1MiIsImYyIiwiU1dSQ29uZmlnQ29udGV4dCIsIlNXUkNvbmZpZyQxIiwicHJvcHMiLCJleHRlbmRlZENvbmZpZyIsImNhY2hlQ29udGV4dCIsIlByb3ZpZGVyIiwidXNlU3RhdGVXaXRoRGVwcyIsInN0YXRlIiwidW5tb3VudGVkUmVmIiwicmVyZW5kZXIiLCJzdGF0ZVJlZiIsInN0YXRlRGVwZW5kZW5jaWVzUmVmIiwic2V0U3RhdGUiLCJwYXlsb2FkIiwic2hvdWxkUmVyZW5kZXIiLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50IiwiayIsIm5vcm1hbGl6ZSIsInVzZVNXUkNvbmZpZyIsIndpdGhBcmdzIiwiaG9vayIsInVzZVNXUkFyZ3MiLCJmYWxsYmFja0NvbmZpZyIsImZuIiwiX2NvbmZpZyIsImZldGNoZXIiLCJzdWJzY3JpYmVDYWxsYmFjayIsImNhbGxiYWNrcyIsImtleWVkUmV2YWxpZGF0b3JzIiwiaW5kZXhPZiIsIldJVEhfREVEVVBFIiwiZGVkdXBlIiwidXNlU1dSSGFuZGxlciIsImZhbGxiYWNrRGF0YSIsInN1c3BlbnNlIiwicmV2YWxpZGF0ZU9uTW91bnQiLCJyZWZyZXNoSW50ZXJ2YWwiLCJyZWZyZXNoV2hlbkhpZGRlbiIsInJlZnJlc2hXaGVuT2ZmbGluZSIsImZuQXJncyIsImluaXRpYWxNb3VudGVkUmVmIiwia2V5UmVmIiwiZmV0Y2hlclJlZiIsImNvbmZpZ1JlZiIsImdldENvbmZpZyIsImlzQWN0aXZlIiwicGF0Y2hGZXRjaEluZm8iLCJpbmZvIiwiY2FjaGVkIiwiaXNJbml0aWFsTW91bnQiLCJzaG91bGRSZXZhbGlkYXRlIiwicmVzb2x2ZVZhbGlkYXRpbmciLCJzdGF0ZURlcGVuZGVuY2llcyIsInJldmFsaWRhdGVPcHRzIiwiY3VycmVudEZldGNoZXIiLCJzdGFydEF0IiwibG9hZGluZyIsInNob3VsZFN0YXJ0TmV3UmVxdWVzdCIsImlzQ3VycmVudEtleU1vdW50ZWQiLCJjbGVhbnVwU3RhdGUiLCJuZXdTdGF0ZSIsImZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSIsIm11dGF0aW9uSW5mbyIsImVycl8xIiwicmVxdWVzdEluZm8iLCJib3VuZE11dGF0ZSIsImtleUNoYW5nZWQiLCJzb2Z0UmV2YWxpZGF0ZSIsIm9uU3RhdGVVcGRhdGUiLCJ1cGRhdGVkRGF0YSIsInVwZGF0ZWRFcnJvciIsInVwZGF0ZWRJc1ZhbGlkYXRpbmciLCJuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0Iiwib25SZXZhbGlkYXRlIiwibm93IiwidW5zdWJVcGRhdGUiLCJ1bnN1YkV2ZW50cyIsInRpbWVyIiwiaW50ZXJ2YWwiLCJleGVjdXRlIiwiY2xlYXJUaW1lb3V0IiwiU1dSQ29uZmlnIiwiZGVmaW5lUHJvcGVydHkiLCJ1bnN0YWJsZV9zZXJpYWxpemUiLCJ1c2VTV1IiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swr/dist/index.mjs\n");

/***/ })

};
;